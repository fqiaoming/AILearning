![å®‰å…¨åˆè§„æ¶æ„](./images/security.svg)
*å›¾ï¼šå®‰å…¨åˆè§„æ¶æ„*

# ç¬¬132è¯¾ï¼šAPIå®‰å…¨ - è®¤è¯ã€é‰´æƒä¸é™æµæœºåˆ¶

> **æœ¬è¯¾ç›®æ ‡**ï¼šæ„å»ºå®Œæ•´çš„APIå®‰å…¨é˜²æŠ¤ä½“ç³»
> 
> **æ ¸å¿ƒæŠ€èƒ½**ï¼šJWTè®¤è¯ã€OAuth2ã€APIé™æµã€CORSé…ç½®
> 
> **å­¦ä¹ æ—¶é•¿**ï¼š90åˆ†é’Ÿ

---

## ğŸ“– å£æ’­æ–‡æ¡ˆï¼ˆ8åˆ†é’Ÿï¼‰
![Api Security](./images/api_security.svg)
*å›¾ï¼šApi Security*


### ğŸ¯ å‰è¨€

"APIæš´éœ²åœ¨äº’è”ç½‘ä¸Šï¼Œ**è°éƒ½èƒ½è®¿é—®ï¼Ÿ**

**å¿…é¡»å»ºç«‹å®‰å…¨é—¨ç¦ï¼**

**APIå®‰å…¨çš„4é“é˜²çº¿ï¼š**

```
é˜²çº¿1ï¼šè®¤è¯ï¼ˆAuthenticationï¼‰
â€¢ ä½ æ˜¯è°ï¼Ÿ
â€¢ éªŒè¯èº«ä»½
â€¢ JWT Token / API Key

é˜²çº¿2ï¼šé‰´æƒï¼ˆAuthorizationï¼‰
â€¢ ä½ èƒ½åšä»€ä¹ˆï¼Ÿ
â€¢ æƒé™æ§åˆ¶
â€¢ RBAC / ABAC

é˜²çº¿3ï¼šé™æµï¼ˆRate Limitingï¼‰
â€¢ ä½ èƒ½è®¿é—®å¤šå°‘æ¬¡ï¼Ÿ
â€¢ é˜²æ­¢æ»¥ç”¨
â€¢ Token Bucket / Leaky Bucket

é˜²çº¿4ï¼šå®¡è®¡ï¼ˆAuditingï¼‰
â€¢ ä½ åšäº†ä»€ä¹ˆï¼Ÿ
â€¢ æ“ä½œè®°å½•
â€¢ æ—¥å¿—è¿½è¸ª

å±‚å±‚æŠŠå…³ï¼
```

**è®¤è¯ vs é‰´æƒï¼š**

```
ã€è®¤è¯ï¼ˆAuthenticationï¼‰ã€‘

åœºæ™¯ï¼šç™»å½•ç³»ç»Ÿ
é—®é¢˜ï¼šä½ æ˜¯è°ï¼Ÿ
æ–¹å¼ï¼š
â€¢ ç”¨æˆ·å+å¯†ç 
â€¢ Token
â€¢ OAuth2
â€¢ ç”Ÿç‰©è¯†åˆ«

ç»“æœï¼šèº«ä»½ç¡®è®¤

ã€é‰´æƒï¼ˆAuthorizationï¼‰ã€‘

åœºæ™¯ï¼šè®¿é—®èµ„æº
é—®é¢˜ï¼šä½ èƒ½è®¿é—®å—ï¼Ÿ
æ–¹å¼ï¼š
â€¢ è§’è‰²æƒé™ï¼ˆRBACï¼‰
â€¢ å±æ€§æƒé™ï¼ˆABACï¼‰
â€¢ ACLè®¿é—®æ§åˆ¶

ç»“æœï¼šæƒé™éªŒè¯

å…³ç³»ï¼š
è®¤è¯åœ¨å‰ï¼Œé‰´æƒåœ¨å
å…ˆéªŒè¯èº«ä»½ï¼Œå†æ£€æŸ¥æƒé™

ç¤ºä¾‹ï¼š
1. ç”¨æˆ·ç™»å½•ï¼ˆè®¤è¯ï¼‰ âœ“
2. è®¿é—®è®¢å•ï¼ˆé‰´æƒï¼‰ 
   â†’ æ£€æŸ¥ï¼šæ˜¯å¦æ˜¯è‡ªå·±çš„è®¢å•ï¼Ÿ
   â†’ å¦‚æœæ˜¯ï¼šå…è®¸ âœ“
   â†’ å¦‚æœä¸æ˜¯ï¼šæ‹’ç» âœ—
```

**JWTçš„ä¼˜åŠ¿ï¼š**

```
ä¼ ç»ŸSessionï¼š

å®¢æˆ·ç«¯          æœåŠ¡å™¨
  |  1. ç™»å½•    |
  |------------>| åˆ›å»ºSession
  |             | å­˜å‚¨åˆ°Redis
  |  2. è¿”å›ID  |
  |<------------|
  |  3. è¯·æ±‚    |
  |------------>| æŸ¥Redis
  |             | éªŒè¯Session
  |  4. å“åº”    |
  |<------------|

é—®é¢˜ï¼š
âœ— æœåŠ¡å™¨éœ€è¦å­˜å‚¨
âœ— æ‰©å±•æ€§å·®ï¼ˆå¤šæœåŠ¡å™¨ï¼‰
âœ— Rediså‹åŠ›å¤§

JWT Tokenï¼š

å®¢æˆ·ç«¯          æœåŠ¡å™¨
  |  1. ç™»å½•    |
  |------------>| ç”ŸæˆJWT
  |             | ç­¾ååŠ å¯†
  |  2. è¿”å›JWT |
  |<------------|
  |  3. è¯·æ±‚+JWT|
  |------------>| éªŒè¯ç­¾å
  |             | è§£æpayload
  |  4. å“åº”    |
  |<------------|

ä¼˜åŠ¿ï¼š
âœ“ æ— éœ€æœåŠ¡å™¨å­˜å‚¨
âœ“ æ°´å¹³æ‰©å±•å‹å¥½
âœ“ åŒ…å«ç”¨æˆ·ä¿¡æ¯
âœ“ è·¨åŸŸå‹å¥½

JWTç»“æ„ï¼š
Header.Payload.Signature

Headerï¼šç®—æ³•å’Œç±»å‹
{
  "alg": "HS256",
  "typ": "JWT"
}

Payloadï¼šæ•°æ®
{
  "user_id": 123,
  "username": "john",
  "exp": 1640000000
}

Signatureï¼šç­¾å
HMACSHA256(
  base64(header) + "." + base64(payload),
  secret_key
)
```

**é™æµç®—æ³•å¯¹æ¯”ï¼š**

```
ç®—æ³•1ï¼šå›ºå®šçª—å£
â€¢ 1åˆ†é’Ÿå†…æœ€å¤š100æ¬¡
â€¢ ç®€å•
â€¢ ä½†æœ‰çªåˆºé—®é¢˜

æ—¶é—´ï¼š  00:00-01:00  01:00-02:00
è¯·æ±‚ï¼š      100         100
æ€»è®¡ï¼š  200æ¬¡/2åˆ†é’Ÿ âœ“

é—®é¢˜ï¼š00:59ç§’100æ¬¡ + 01:01ç§’100æ¬¡ = 2ç§’200æ¬¡ï¼

ç®—æ³•2ï¼šæ»‘åŠ¨çª—å£
â€¢ ä»»æ„1åˆ†é’Ÿæœ€å¤š100æ¬¡
â€¢ ç²¾ç¡®
â€¢ å†…å­˜æ¶ˆè€—å¤§

ç®—æ³•3ï¼šä»¤ç‰Œæ¡¶ï¼ˆToken Bucketï¼‰
â€¢ å›ºå®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œ
â€¢ è¯·æ±‚æ¶ˆè€—ä»¤ç‰Œ
â€¢ å…è®¸çªå‘æµé‡

å®¹é‡ï¼š10ä¸ªä»¤ç‰Œ
é€Ÿç‡ï¼š1ä¸ª/ç§’

çªå‘ï¼šå¯ä»¥ä¸€æ¬¡ç”¨å®Œ10ä¸ª
å¹³å‡ï¼šæ¯ç§’æœ€å¤š1ä¸ª

ç®—æ³•4ï¼šæ¼æ¡¶ï¼ˆLeaky Bucketï¼‰
â€¢ å›ºå®šé€Ÿç‡å¤„ç†è¯·æ±‚
â€¢ è¯·æ±‚æ”¾å…¥é˜Ÿåˆ—
â€¢ å¹³æ»‘æµé‡

å®¹é‡ï¼š10ä¸ªè¯·æ±‚
é€Ÿç‡ï¼š1ä¸ª/ç§’

æ— è®ºè¯·æ±‚å¤šå°‘ï¼Œéƒ½æŒ‰å›ºå®šé€Ÿç‡å¤„ç†

æ¨èï¼šä»¤ç‰Œæ¡¶ï¼ˆçµæ´»+é«˜æ•ˆï¼‰
```

**ä»Šå¤©è¿™ä¸€è¯¾ï¼Œæˆ‘è¦å¸¦ä½ ï¼š**

**ç¬¬ä¸€éƒ¨åˆ†ï¼šJWTè®¤è¯**
- JWTç”Ÿæˆ
- TokenéªŒè¯
- åˆ·æ–°æœºåˆ¶

**ç¬¬äºŒéƒ¨åˆ†ï¼šæƒé™æ§åˆ¶**
- RBACå®ç°
- æƒé™è£…é¥°å™¨
- åŠ¨æ€æƒé™

**ç¬¬ä¸‰éƒ¨åˆ†ï¼šAPIé™æµ**
- é™æµç®—æ³•
- Redisé™æµ
- åˆ†å¸ƒå¼é™æµ

**ç¬¬å››éƒ¨åˆ†ï¼šå®‰å…¨headers**
- CORSé…ç½®
- å®‰å…¨å“åº”å¤´
- APIå¯†é’¥

å»ºç«‹APIå®‰å…¨ä½“ç³»ï¼"

---

## ğŸ“š ç¬¬ä¸€éƒ¨åˆ†ï¼šJWTè®¤è¯ç³»ç»Ÿ

### ä¸€ã€JWTå®ç°

```python
# app/core/security.py
from datetime import datetime, timedelta
from typing import Optional, Dict
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

from app.config import get_settings

settings = get_settings()

# å¯†ç ä¸Šä¸‹æ–‡
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# JWT Bearer
security = HTTPBearer()

class JWTManager:
    """JWTç®¡ç†å™¨"""
    
    SECRET_KEY = settings.SECRET_KEY
    ALGORITHM = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES = 30
    REFRESH_TOKEN_EXPIRE_DAYS = 7
    
    @classmethod
    def create_access_token(
        cls,
        data: Dict,
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """
        åˆ›å»ºè®¿é—®Token
        
        Args:
            data: è½½è·æ•°æ®
            expires_delta: è¿‡æœŸæ—¶é—´
        
        Returns:
            JWT Token
        """
        to_encode = data.copy()
        
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(
                minutes=cls.ACCESS_TOKEN_EXPIRE_MINUTES
            )
        
        to_encode.update({
            "exp": expire,
            "iat": datetime.utcnow(),
            "type": "access"
        })
        
        encoded_jwt = jwt.encode(
            to_encode,
            cls.SECRET_KEY,
            algorithm=cls.ALGORITHM
        )
        
        return encoded_jwt
    
    @classmethod
    def create_refresh_token(cls, data: Dict) -> str:
        """
        åˆ›å»ºåˆ·æ–°Token
        
        Args:
            data: è½½è·æ•°æ®
        
        Returns:
            Refresh Token
        """
        to_encode = data.copy()
        
        expire = datetime.utcnow() + timedelta(days=cls.REFRESH_TOKEN_EXPIRE_DAYS)
        
        to_encode.update({
            "exp": expire,
            "iat": datetime.utcnow(),
            "type": "refresh"
        })
        
        encoded_jwt = jwt.encode(
            to_encode,
            cls.SECRET_KEY,
            algorithm=cls.ALGORITHM
        )
        
        return encoded_jwt
    
    @classmethod
    def verify_token(cls, token: str) -> Dict:
        """
        éªŒè¯Token
        
        Args:
            token: JWT Token
        
        Returns:
            è½½è·æ•°æ®
        
        Raises:
            HTTPException: Tokenæ— æ•ˆ
        """
        try:
            payload = jwt.decode(
                token,
                cls.SECRET_KEY,
                algorithms=[cls.ALGORITHM]
            )
            
            # æ£€æŸ¥è¿‡æœŸæ—¶é—´
            exp = payload.get("exp")
            if exp and datetime.fromtimestamp(exp) < datetime.utcnow():
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Tokenå·²è¿‡æœŸ"
                )
            
            return payload
        
        except JWTError as e:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Tokenæ— æ•ˆ: {str(e)}"
            )
    
    @classmethod
    def decode_token(cls, token: str) -> Optional[Dict]:
        """
        è§£ç Tokenï¼ˆä¸éªŒè¯ï¼‰
        
        Args:
            token: JWT Token
        
        Returns:
            è½½è·æ•°æ®æˆ–None
        """
        try:
            payload = jwt.decode(
                token,
                cls.SECRET_KEY,
                algorithms=[cls.ALGORITHM],
                options={"verify_exp": False}
            )
            return payload
        except:
            return None

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict:
    """
    è·å–å½“å‰ç”¨æˆ·
    
    Args:
        credentials: è®¤è¯å‡­è¯
    
    Returns:
        ç”¨æˆ·ä¿¡æ¯
    """
    token = credentials.credentials
    payload = JWTManager.verify_token(token)
    
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="æ— æ•ˆçš„Token"
        )
    
    # ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆå®é™…åº”ç”¨ä¸­ï¼‰
    # user = await get_user_from_db(user_id)
    
    return {
        "user_id": user_id,
        "username": payload.get("username"),
        "role": payload.get("role", "user")
    }

# ä½¿ç”¨ç¤ºä¾‹
from fastapi import APIRouter

router = APIRouter()

@router.post("/login")
async def login(username: str, password: str):
    """ç™»å½•"""
    
    # éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆå®é™…åº”ç”¨ä¸­æŸ¥æ•°æ®åº“ï¼‰
    # user = await authenticate_user(username, password)
    
    # ç”ŸæˆToken
    access_token = JWTManager.create_access_token(
        data={"user_id": 123, "username": username, "role": "user"}
    )
    
    refresh_token = JWTManager.create_refresh_token(
        data={"user_id": 123}
    )
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@router.post("/refresh")
async def refresh_token(refresh_token: str):
    """åˆ·æ–°Token"""
    
    payload = JWTManager.verify_token(refresh_token)
    
    # æ£€æŸ¥æ˜¯å¦æ˜¯refresh token
    if payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="æ— æ•ˆçš„åˆ·æ–°Token"
        )
    
    # ç”Ÿæˆæ–°çš„access token
    user_id = payload.get("user_id")
    access_token = JWTManager.create_access_token(
        data={"user_id": user_id}
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

@router.get("/me")
async def get_me(current_user: Dict = Depends(get_current_user)):
    """è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯"""
    return current_user
```

---

## ğŸ’» ç¬¬äºŒéƒ¨åˆ†ï¼šæƒé™æ§åˆ¶ç³»ç»Ÿ

### ä¸€ã€RBACå®ç°

```python
# app/core/permissions.py
from enum import Enum
from typing import List, Set
from fastapi import HTTPException, status, Depends
from functools import wraps

class Role(str, Enum):
    """ç”¨æˆ·è§’è‰²"""
    ADMIN = "admin"
    MANAGER = "manager"
    USER = "user"
    GUEST = "guest"

class Permission(str, Enum):
    """æƒé™"""
    # ç”¨æˆ·ç®¡ç†
    USER_READ = "user:read"
    USER_WRITE = "user:write"
    USER_DELETE = "user:delete"
    
    # é¢„æµ‹
    PREDICT_READ = "predict:read"
    PREDICT_WRITE = "predict:write"
    
    # æ¨¡å‹ç®¡ç†
    MODEL_READ = "model:read"
    MODEL_WRITE = "model:write"
    MODEL_DELETE = "model:delete"
    
    # ç³»ç»Ÿ
    SYSTEM_READ = "system:read"
    SYSTEM_WRITE = "system:write"

# è§’è‰²æƒé™æ˜ å°„
ROLE_PERMISSIONS: Dict[Role, Set[Permission]] = {
    Role.ADMIN: {
        # ç®¡ç†å‘˜ï¼šæ‰€æœ‰æƒé™
        Permission.USER_READ,
        Permission.USER_WRITE,
        Permission.USER_DELETE,
        Permission.PREDICT_READ,
        Permission.PREDICT_WRITE,
        Permission.MODEL_READ,
        Permission.MODEL_WRITE,
        Permission.MODEL_DELETE,
        Permission.SYSTEM_READ,
        Permission.SYSTEM_WRITE,
    },
    
    Role.MANAGER: {
        # ç®¡ç†è€…ï¼šéƒ¨åˆ†æƒé™
        Permission.USER_READ,
        Permission.USER_WRITE,
        Permission.PREDICT_READ,
        Permission.PREDICT_WRITE,
        Permission.MODEL_READ,
        Permission.SYSTEM_READ,
    },
    
    Role.USER: {
        # æ™®é€šç”¨æˆ·ï¼šåŸºæœ¬æƒé™
        Permission.USER_READ,
        Permission.PREDICT_READ,
        Permission.PREDICT_WRITE,
        Permission.MODEL_READ,
    },
    
    Role.GUEST: {
        # è®¿å®¢ï¼šåªè¯»æƒé™
        Permission.USER_READ,
        Permission.PREDICT_READ,
        Permission.MODEL_READ,
    }
}

class PermissionChecker:
    """æƒé™æ£€æŸ¥å™¨"""
    
    @staticmethod
    def has_permission(user_role: str, required_permission: Permission) -> bool:
        """
        æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
        
        Args:
            user_role: ç”¨æˆ·è§’è‰²
            required_permission: æ‰€éœ€æƒé™
        
        Returns:
            æ˜¯å¦æœ‰æƒé™
        """
        try:
            role = Role(user_role)
            permissions = ROLE_PERMISSIONS.get(role, set())
            return required_permission in permissions
        except ValueError:
            return False
    
    @staticmethod
    def check_permission(user_role: str, required_permission: Permission):
        """
        æ£€æŸ¥æƒé™ï¼ˆæŠ›å‡ºå¼‚å¸¸ï¼‰
        
        Args:
            user_role: ç”¨æˆ·è§’è‰²
            required_permission: æ‰€éœ€æƒé™
        
        Raises:
            HTTPException: æ— æƒé™
        """
        if not PermissionChecker.has_permission(user_role, required_permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"éœ€è¦æƒé™ï¼š{required_permission.value}"
            )

def require_permission(permission: Permission):
    """
    æƒé™è£…é¥°å™¨
    
    Args:
        permission: æ‰€éœ€æƒé™
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # ä»kwargsè·å–current_user
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="æœªè®¤è¯"
                )
            
            # æ£€æŸ¥æƒé™
            user_role = current_user.get('role', 'guest')
            PermissionChecker.check_permission(user_role, permission)
            
            # æ‰§è¡Œå‡½æ•°
            return await func(*args, **kwargs)
        
        return wrapper
    return decorator

def require_role(role: Role):
    """
    è§’è‰²è£…é¥°å™¨
    
    Args:
        role: æ‰€éœ€è§’è‰²
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="æœªè®¤è¯"
                )
            
            user_role = current_user.get('role', 'guest')
            if user_role != role.value:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"éœ€è¦è§’è‰²ï¼š{role.value}"
                )
            
            return await func(*args, **kwargs)
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
from fastapi import APIRouter
from app.core.security import get_current_user

router = APIRouter()

@router.delete("/users/{user_id}")
@require_permission(Permission.USER_DELETE)
async def delete_user(
    user_id: int,
    current_user: Dict = Depends(get_current_user)
):
    """åˆ é™¤ç”¨æˆ·ï¼ˆéœ€è¦æƒé™ï¼‰"""
    return {"message": f"ç”¨æˆ·{user_id}å·²åˆ é™¤"}

@router.post("/models")
@require_role(Role.ADMIN)
async def create_model(
    model_data: dict,
    current_user: Dict = Depends(get_current_user)
):
    """åˆ›å»ºæ¨¡å‹ï¼ˆä»…ç®¡ç†å‘˜ï¼‰"""
    return {"message": "æ¨¡å‹å·²åˆ›å»º"}
```

---

## ğŸ¯ ç¬¬ä¸‰éƒ¨åˆ†ï¼šAPIé™æµ

### ä¸€ã€Redisé™æµå®ç°

```python
# app/middleware/rate_limit.py
import time
from typing import Optional
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
import redis

from app.config import get_settings

settings = get_settings()

class RateLimiter:
    """é™æµå™¨ï¼ˆä»¤ç‰Œæ¡¶ç®—æ³•ï¼‰"""
    
    def __init__(self, redis_client: redis.Redis):
        """åˆå§‹åŒ–"""
        self.redis = redis_client
    
    async def is_allowed(
        self,
        key: str,
        max_requests: int = 100,
        window_seconds: int = 60
    ) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚ï¼ˆä»¤ç‰Œæ¡¶ï¼‰
        
        Args:
            key: é™æµé”®ï¼ˆIP/ç”¨æˆ·IDï¼‰
            max_requests: æœ€å¤§è¯·æ±‚æ•°
            window_seconds: æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        
        Returns:
            æ˜¯å¦å…è®¸
        """
        now = time.time()
        window_key = f"rate_limit:{key}:{int(now / window_seconds)}"
        
        pipe = self.redis.pipeline()
        pipe.incr(window_key)
        pipe.expire(window_key, window_seconds)
        results = pipe.execute()
        
        current_requests = results[0]
        
        return current_requests <= max_requests
    
    async def check_rate_limit(
        self,
        key: str,
        max_requests: int = 100,
        window_seconds: int = 60
    ):
        """
        æ£€æŸ¥é™æµï¼ˆæŠ›å‡ºå¼‚å¸¸ï¼‰
        
        Args:
            key: é™æµé”®
            max_requests: æœ€å¤§è¯·æ±‚æ•°
            window_seconds: æ—¶é—´çª—å£
        
        Raises:
            HTTPException: è¶…è¿‡é™æµ
        """
        if not await self.is_allowed(key, max_requests, window_seconds):
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=f"è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·{window_seconds}ç§’åé‡è¯•"
            )

class RateLimitMiddleware(BaseHTTPMiddleware):
    """é™æµä¸­é—´ä»¶"""
    
    def __init__(self, app, redis_url: str):
        """åˆå§‹åŒ–"""
        super().__init__(app)
        self.redis = redis.from_url(redis_url, decode_responses=True)
        self.limiter = RateLimiter(self.redis)
    
    async def dispatch(self, request: Request, call_next):
        """å¤„ç†è¯·æ±‚"""
        
        # è·å–å®¢æˆ·ç«¯IP
        client_ip = request.client.host
        
        # ä¸åŒè·¯å¾„ä¸åŒé™æµ
        path = request.url.path
        
        if path.startswith("/api/v1/predict"):
            # é¢„æµ‹æ¥å£ï¼šæ¯åˆ†é’Ÿ100æ¬¡
            await self.limiter.check_rate_limit(
                key=f"predict:{client_ip}",
                max_requests=100,
                window_seconds=60
            )
        elif path.startswith("/api/v1/users"):
            # ç”¨æˆ·æ¥å£ï¼šæ¯åˆ†é’Ÿ50æ¬¡
            await self.limiter.check_rate_limit(
                key=f"users:{client_ip}",
                max_requests=50,
                window_seconds=60
            )
        
        # ç»§ç»­å¤„ç†
        response = await call_next(request)
        
        return response

# ä½¿ç”¨
from fastapi import FastAPI

app = FastAPI()

# æ·»åŠ é™æµä¸­é—´ä»¶
app.add_middleware(
    RateLimitMiddleware,
    redis_url=settings.REDIS_URL
)
```

---

## ğŸ“ è¯¾åæ€»ç»“

### æ ¸å¿ƒæ”¶è·

1. **JWTè®¤è¯**
   - Tokenç”Ÿæˆ
   - TokenéªŒè¯
   - åˆ·æ–°æœºåˆ¶

2. **æƒé™æ§åˆ¶**
   - RBACå®ç°
   - æƒé™è£…é¥°å™¨
   - è§’è‰²ç®¡ç†

3. **APIé™æµ**
   - ä»¤ç‰Œæ¡¶ç®—æ³•
   - Rediså®ç°
   - åˆ†çº§é™æµ

4. **å®‰å…¨é˜²æŠ¤**
   - è®¤è¯+é‰´æƒ
   - é™æµ+å®¡è®¡
   - å®Œæ•´é˜²çº¿

---

## ğŸš€ ä¸‹èŠ‚é¢„å‘Š

ä¸‹ä¸€è¯¾ï¼š**ç¬¬133è¯¾ï¼šåˆè§„æ€§ - GDPRä¸æ•°æ®ä¿æŠ¤**

- GDPRè¦æ±‚
- æ•°æ®ä¿æŠ¤
- éšç§æ”¿ç­–
- åˆè§„å®¡è®¡

**åˆæ³•åˆè§„ï¼** ğŸ”¥

---

**ğŸ’ª APIå®‰å…¨ä½“ç³»å»ºç«‹å®Œæˆï¼å›ºè‹¥é‡‘æ±¤ï¼**

**ä¸‹ä¸€è¯¾è§ï¼** ğŸ‰
