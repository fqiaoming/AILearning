![å·¥ç¨‹åŒ–æ¶æ„](./images/engineering.svg)
*å›¾ï¼šå·¥ç¨‹åŒ–æ¶æ„*

# ç¬¬127è¯¾ï¼šæµ‹è¯•ä¸è´¨é‡ - å•å…ƒæµ‹è¯•ä¸é›†æˆæµ‹è¯•

> **æœ¬è¯¾ç›®æ ‡**ï¼šæŒæ¡å®Œæ•´çš„æµ‹è¯•ä½“ç³»å’Œè´¨é‡ä¿è¯æ–¹æ³•
> 
> **æ ¸å¿ƒæŠ€èƒ½**ï¼šPytestã€æµ‹è¯•é‡‘å­—å¡”ã€è¦†ç›–ç‡ã€CI/CDé›†æˆ
> 
> **å­¦ä¹ æ—¶é•¿**ï¼š90åˆ†é’Ÿ

---

## ğŸ“– å£æ’­æ–‡æ¡ˆï¼ˆ8åˆ†é’Ÿï¼‰
![Monitoring](./images/monitoring.svg)
*å›¾ï¼šMonitoring*


### ğŸ¯ å‰è¨€

"ä»£ç å†™å®Œäº†ï¼Œå¦‚ä½•ä¿è¯è´¨é‡ï¼Ÿ**æµ‹è¯•ï¼**

**ä¸ºä»€ä¹ˆæµ‹è¯•å¦‚æ­¤é‡è¦ï¼Ÿ**

```
çœŸå®äº‹æ•…ï¼š

æ¡ˆä¾‹1ï¼šAri

ana Grandeäº‹ä»¶ï¼ˆ2018ï¼‰
â€¢ AppleéŸ³ä¹æ¨èBug
â€¢ æ¨èç®—æ³•é”™è¯¯
â€¢ ç”¨æˆ·æ•°æ®æ··ä¹±
â€¢ æŸå¤±æ•°ç™¾ä¸‡ç¾å…ƒ

åŸå› ï¼šç¼ºå°‘é›†æˆæµ‹è¯•

æ¡ˆä¾‹2ï¼šFacebookå®•æœºï¼ˆ2021ï¼‰
â€¢ é…ç½®å˜æ›´æœªæµ‹è¯•
â€¢ å…¨çƒæœåŠ¡ä¸­æ–­6å°æ—¶
â€¢ æŸå¤±è¶…è¿‡1äº¿ç¾å…ƒ

åŸå› ï¼šç¼ºå°‘å›å½’æµ‹è¯•

æ¡ˆä¾‹3ï¼šTeslaè‡ªåŠ¨é©¾é©¶Bug
â€¢ è¯†åˆ«ç®—æ³•å¤±è¯¯
â€¢ å®‰å…¨äº‹æ•…
â€¢ å£°èª‰å—æŸ

åŸå› ï¼šç¼ºå°‘è¾¹ç•Œæµ‹è¯•

æ•™è®­ï¼šæµ‹è¯•ä¸æ˜¯æˆæœ¬ï¼Œæ˜¯æŠ•èµ„ï¼
```

**æµ‹è¯•é‡‘å­—å¡”ï¼š**

```
        â•±â•²
       â•±E2Eâ•²        10%  - ç«¯åˆ°ç«¯æµ‹è¯•
      â•±â”€â”€â”€â”€â”€â”€â•²
     â•±  é›†æˆ   â•²     20%  - é›†æˆæµ‹è¯•
    â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
   â•±   å•å…ƒæµ‹è¯•  â•²   70%  - å•å…ƒæµ‹è¯•
  â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²
 â•±  é™æ€æ£€æŸ¥+Lint â•²  åŸºç¡€  - è‡ªåŠ¨åŒ–æ£€æŸ¥
â•±â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•²

åŸåˆ™ï¼š
â€¢ åº•å±‚å¤šã€ä¸Šå±‚å°‘
â€¢ å¿«é€Ÿã€ç¨³å®šã€å»‰ä»·
â€¢ æŠ•å…¥äº§å‡ºæ¯”æœ€ä¼˜
```

**å•å…ƒæµ‹è¯• vs é›†æˆæµ‹è¯•ï¼š**

```
å•å…ƒæµ‹è¯•ï¼š
â€¢ æµ‹è¯•å•ä¸ªå‡½æ•°/ç±»
â€¢ å¿«é€Ÿï¼ˆæ¯«ç§’çº§ï¼‰
â€¢ éš”ç¦»ï¼ˆMockä¾èµ–ï¼‰
â€¢ è¦†ç›–ç‡é«˜

ç¤ºä¾‹ï¼š
def test_calculate_sum():
    assert calculate_sum(1, 2) == 3
    assert calculate_sum(-1, 1) == 0
    assert calculate_sum(0, 0) == 0

é›†æˆæµ‹è¯•ï¼š
â€¢ æµ‹è¯•æ¨¡å—åä½œ
â€¢ è¾ƒæ…¢ï¼ˆç§’çº§ï¼‰
â€¢ çœŸå®ä¾èµ–
â€¢ ç«¯åˆ°ç«¯æµç¨‹

ç¤ºä¾‹ï¼š
def test_predict_api():
    response = client.post("/predict", json={
        "text": "æµ‹è¯•"
    })
    assert response.status_code == 200
    assert "result" in response.json()

äº’è¡¥å…³ç³»ï¼
```

**æµ‹è¯•è¦†ç›–ç‡çš„é™·é˜±ï¼š**

```
é”™è¯¯è§‚å¿µï¼š
"æˆ‘çš„ä»£ç 100%è¦†ç›–ç‡ï¼Œæ²¡Bugï¼"

çœŸç›¸ï¼š
âœ— è¦†ç›–ç‡â‰ è´¨é‡
âœ— 100%è¦†ç›–ä¹Ÿå¯èƒ½æœ‰Bug
âœ“ è¦†ç›–ç‡æ˜¯å¿…è¦æ¡ä»¶ï¼Œä¸æ˜¯å……åˆ†æ¡ä»¶

ç¤ºä¾‹ï¼š
def divide(a, b):
    return a / b

# æµ‹è¯•ï¼ˆæœ‰è¦†ç›–ç‡ï¼‰
def test_divide():
    assert divide(10, 2) == 5

âœ— æ²¡æµ‹è¯• b=0 çš„æƒ…å†µ
âœ— è¿è¡Œæ—¶ä¼šå´©æºƒ
âœ“ 100%ä»£ç è¦†ç›–
âœ— 0%è¾¹ç•Œè¦†ç›–

æ­£ç¡®åšæ³•ï¼š
def test_divide():
    assert divide(10, 2) == 5
    assert divide(0, 1) == 0
    with pytest.raises(ZeroDivisionError):
        divide(1, 0)

å…¨é¢ï¼
```

**Pytestçš„ä¼˜åŠ¿ï¼š**

```
å¯¹æ¯”unittestï¼š

unittestï¼ˆæ ‡å‡†åº“ï¼‰ï¼š
class TestExample(unittest.TestCase):
    def setUp(self):
        self.data = setup_data()
    
    def test_something(self):
        self.assertEqual(func(), expected)
    
    def tearDown(self):
        cleanup()

â€¢ å•°å—¦
â€¢ ç±»ç»“æ„
â€¢ ä¸çµæ´»

pytestï¼ˆæ¨èï¼‰ï¼š
def test_something():
    assert func() == expected

â€¢ ç®€æ´
â€¢ å‡½æ•°é£æ ¼
â€¢ çµæ´»å¼ºå¤§

è¿˜æœ‰ï¼š
âœ“ Fixtureç³»ç»Ÿ
âœ“ å‚æ•°åŒ–æµ‹è¯•
âœ“ æ’ä»¶ç”Ÿæ€
âœ“ è¯¦ç»†è¾“å‡º

ç°ä»£Pythonæµ‹è¯•æ ‡å‡†ï¼
```

**ä»Šå¤©è¿™ä¸€è¯¾ï¼Œæˆ‘è¦å¸¦ä½ ï¼š**

**ç¬¬ä¸€éƒ¨åˆ†ï¼šå•å…ƒæµ‹è¯•**
- PyteståŸºç¡€
- Fixtureä½¿ç”¨
- å‚æ•°åŒ–æµ‹è¯•
- MockæŠ€å·§

**ç¬¬äºŒéƒ¨åˆ†ï¼šé›†æˆæµ‹è¯•**
- APIæµ‹è¯•
- æ•°æ®åº“æµ‹è¯•
- å¼‚æ­¥æµ‹è¯•

**ç¬¬ä¸‰éƒ¨åˆ†ï¼šæµ‹è¯•è¦†ç›–ç‡**
- Coverageå·¥å…·
- è¦†ç›–ç‡åˆ†æ
- è´¨é‡é—¨ç¦

**ç¬¬å››éƒ¨åˆ†ï¼šCI/CDé›†æˆ**
- GitHub Actions
- è‡ªåŠ¨åŒ–æµ‹è¯•
- æµ‹è¯•æŠ¥å‘Š

å»ºç«‹å®Œæ•´æµ‹è¯•ä½“ç³»ï¼"

---

## ğŸ“š ç¬¬ä¸€éƒ¨åˆ†ï¼šå•å…ƒæµ‹è¯•å®æˆ˜

### ä¸€ã€PyteståŸºç¡€

```python
# tests/test_basic.py
import pytest
from app.services.prediction import PredictionService
from app.utils.helpers import clean_text, validate_input

class TestCleanText:
    """æ–‡æœ¬æ¸…æ´—æµ‹è¯•"""
    
    def test_remove_whitespace(self):
        """æµ‹è¯•ç§»é™¤ç©ºç™½"""
        assert clean_text("  hello  ") == "hello"
        assert clean_text("\nhello\t") == "hello"
    
    def test_lowercase(self):
        """æµ‹è¯•è½¬å°å†™"""
        assert clean_text("HELLO") == "hello"
        assert clean_text("HeLLo") == "hello"
    
    def test_empty_string(self):
        """æµ‹è¯•ç©ºå­—ç¬¦ä¸²"""
        assert clean_text("") == ""
        assert clean_text("   ") == ""
    
    def test_special_characters(self):
        """æµ‹è¯•ç‰¹æ®Šå­—ç¬¦"""
        assert clean_text("hello@world") == "hello@world"
        assert clean_text("hello\nworld") == "hello world"

class TestValidateInput:
    """è¾“å…¥éªŒè¯æµ‹è¯•"""
    
    def test_valid_input(self):
        """æµ‹è¯•æœ‰æ•ˆè¾“å…¥"""
        assert validate_input("hello", min_length=1, max_length=10) == True
    
    def test_too_short(self):
        """æµ‹è¯•è¿‡çŸ­è¾“å…¥"""
        with pytest.raises(ValueError, match="è¾“å…¥è¿‡çŸ­"):
            validate_input("", min_length=1)
    
    def test_too_long(self):
        """æµ‹è¯•è¿‡é•¿è¾“å…¥"""
        with pytest.raises(ValueError, match="è¾“å…¥è¿‡é•¿"):
            validate_input("a" * 1001, max_length=1000)
    
    def test_invalid_type(self):
        """æµ‹è¯•é”™è¯¯ç±»å‹"""
        with pytest.raises(TypeError):
            validate_input(123)
    
    @pytest.mark.parametrize("input_text,expected", [
        ("hello", True),
        ("world", True),
        ("test123", True),
    ])
    def test_multiple_valid_inputs(self, input_text, expected):
        """å‚æ•°åŒ–æµ‹è¯•å¤šä¸ªè¾“å…¥"""
        assert validate_input(input_text) == expected
```

### äºŒã€Fixtureä½¿ç”¨

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.models.database import Base, get_db

# æµ‹è¯•æ•°æ®åº“
TEST_DATABASE_URL = "sqlite:///./test.db"

@pytest.fixture(scope="session")
def test_db_engine():
    """åˆ›å»ºæµ‹è¯•æ•°æ®åº“å¼•æ“"""
    engine = create_engine(
        TEST_DATABASE_URL,
        connect_args={"check_same_thread": False}
    )
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def test_db_session(test_db_engine):
    """åˆ›å»ºæµ‹è¯•æ•°æ®åº“ä¼šè¯"""
    TestingSessionLocal = sessionmaker(
        autocommit=False,
        autoflush=False,
        bind=test_db_engine
    )
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.rollback()
        session.close()

@pytest.fixture(scope="function")
def client(test_db_session):
    """åˆ›å»ºæµ‹è¯•å®¢æˆ·ç«¯"""
    def override_get_db():
        try:
            yield test_db_session
        finally:
            test_db_session.close()
    
    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()

@pytest.fixture
def sample_user():
    """ç¤ºä¾‹ç”¨æˆ·"""
    return {
        "username": "testuser",
        "email": "test@example.com",
        "password": "testpass123"
    }

@pytest.fixture
def sample_predict_request():
    """ç¤ºä¾‹é¢„æµ‹è¯·æ±‚"""
    return {
        "text": "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ–‡æœ¬",
        "model_name": "default",
        "temperature": 0.7,
        "max_tokens": 100
    }
```

### ä¸‰ã€MockæŠ€å·§

```python
# tests/test_services.py
import pytest
from unittest.mock import Mock, patch, MagicMock
from app.services.prediction import PredictionService

class TestPredictionService:
    """é¢„æµ‹æœåŠ¡æµ‹è¯•"""
    
    @patch('app.services.prediction.load_model')
    def test_predict_with_mock_model(self, mock_load_model):
        """ä½¿ç”¨Mockæµ‹è¯•é¢„æµ‹"""
        
        # è®¾ç½®Mock
        mock_model = Mock()
        mock_model.predict.return_value = {
            "result": "æµ‹è¯•ç»“æœ",
            "confidence": 0.95
        }
        mock_load_model.return_value = mock_model
        
        # æ‰§è¡Œæµ‹è¯•
        service = PredictionService()
        result = service.predict("æµ‹è¯•è¾“å…¥")
        
        # éªŒè¯
        assert result["result"] == "æµ‹è¯•ç»“æœ"
        assert result["confidence"] == 0.95
        mock_model.predict.assert_called_once_with("æµ‹è¯•è¾“å…¥")
    
    @patch('app.services.prediction.requests.post')
    def test_predict_api_call(self, mock_post):
        """Mock APIè°ƒç”¨"""
        
        # è®¾ç½®Mockå“åº”
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "result": "APIç»“æœ"
        }
        mock_post.return_value = mock_response
        
        # æ‰§è¡Œæµ‹è¯•
        service = PredictionService()
        result = service.predict_via_api("æµ‹è¯•")
        
        # éªŒè¯
        assert result["result"] == "APIç»“æœ"
        mock_post.assert_called_once()
    
    @pytest.mark.asyncio
    @patch('app.services.prediction.async_call')
    async def test_async_predict(self, mock_async_call):
        """æµ‹è¯•å¼‚æ­¥é¢„æµ‹"""
        
        # è®¾ç½®Mock
        mock_async_call.return_value = {"result": "å¼‚æ­¥ç»“æœ"}
        
        # æ‰§è¡Œæµ‹è¯•
        service = PredictionService()
        result = await service.predict_async("æµ‹è¯•")
        
        # éªŒè¯
        assert result["result"] == "å¼‚æ­¥ç»“æœ"
```

---

## ğŸ’» ç¬¬äºŒéƒ¨åˆ†ï¼šé›†æˆæµ‹è¯•

### ä¸€ã€APIé›†æˆæµ‹è¯•

```python
# tests/test_api_integration.py
import pytest
from fastapi.testclient import TestClient

class TestPredictAPI:
    """é¢„æµ‹APIé›†æˆæµ‹è¯•"""
    
    def test_predict_success(self, client, sample_predict_request):
        """æµ‹è¯•é¢„æµ‹æˆåŠŸ"""
        response = client.post("/api/v1/predict", json=sample_predict_request)
        
        assert response.status_code == 200
        data = response.json()
        
        assert data["success"] == True
        assert "data" in data
        assert "request_id" in data
        assert "timestamp" in data
    
    def test_predict_invalid_input(self, client):
        """æµ‹è¯•æ— æ•ˆè¾“å…¥"""
        response = client.post("/api/v1/predict", json={
            "text": "",  # ç©ºæ–‡æœ¬
            "temperature": 5.0  # è¶…å‡ºèŒƒå›´
        })
        
        assert response.status_code == 422
        data = response.json()
        assert data["success"] == False
    
    def test_predict_rate_limit(self, client, sample_predict_request):
        """æµ‹è¯•é™æµ"""
        # å‘é€å¤§é‡è¯·æ±‚
        for i in range(150):
            response = client.post("/api/v1/predict", json=sample_predict_request)
            
            if i < 100:
                assert response.status_code == 200
            else:
                # åº”è¯¥è¢«é™æµ
                assert response.status_code == 429
    
    def test_predict_with_authentication(self, client, sample_predict_request):
        """æµ‹è¯•è®¤è¯"""
        # æ— token
        response = client.post("/api/v1/predict", json=sample_predict_request)
        assert response.status_code == 401
        
        # æœ‰æ•ˆtoken
        headers = {"Authorization": "Bearer valid_token"}
        response = client.post(
            "/api/v1/predict",
            json=sample_predict_request,
            headers=headers
        )
        assert response.status_code == 200
    
    def test_predict_error_handling(self, client):
        """æµ‹è¯•é”™è¯¯å¤„ç†"""
        # è§¦å‘å†…éƒ¨é”™è¯¯
        response = client.post("/api/v1/predict", json={
            "text": "trigger_error",
            "model_name": "non_existent_model"
        })
        
        assert response.status_code == 500
        data = response.json()
        assert data["success"] == False
        assert "request_id" in data

class TestHealthAPI:
    """å¥åº·æ£€æŸ¥APIæµ‹è¯•"""
    
    def test_health_check(self, client):
        """æµ‹è¯•å¥åº·æ£€æŸ¥"""
        response = client.get("/api/v1/health")
        
        assert response.status_code == 200
        data = response.json()
        
        assert data["status"] == "healthy"
        assert "version" in data
        assert "uptime" in data
    
    def test_readiness_check(self, client):
        """æµ‹è¯•å°±ç»ªæ£€æŸ¥"""
        response = client.get("/api/v1/ready")
        
        assert response.status_code == 200
        data = response.json()
        
        assert data["ready"] == True
        assert data["database"] == "connected"
        assert data["model"] == "loaded"
```

### äºŒã€æ•°æ®åº“é›†æˆæµ‹è¯•

```python
# tests/test_database_integration.py
import pytest
from app.models.database import User, Prediction
from app.services.user import UserService

class TestUserDatabase:
    """ç”¨æˆ·æ•°æ®åº“æµ‹è¯•"""
    
    def test_create_user(self, test_db_session, sample_user):
        """æµ‹è¯•åˆ›å»ºç”¨æˆ·"""
        service = UserService(test_db_session)
        
        user = service.create_user(**sample_user)
        
        assert user.id is not None
        assert user.username == sample_user["username"]
        assert user.email == sample_user["email"]
    
    def test_get_user(self, test_db_session, sample_user):
        """æµ‹è¯•è·å–ç”¨æˆ·"""
        service = UserService(test_db_session)
        
        # åˆ›å»º
        created_user = service.create_user(**sample_user)
        
        # è·å–
        user = service.get_user(created_user.id)
        
        assert user.id == created_user.id
        assert user.username == sample_user["username"]
    
    def test_update_user(self, test_db_session, sample_user):
        """æµ‹è¯•æ›´æ–°ç”¨æˆ·"""
        service = UserService(test_db_session)
        
        user = service.create_user(**sample_user)
        
        # æ›´æ–°
        updated = service.update_user(user.id, email="new@example.com")
        
        assert updated.email == "new@example.com"
    
    def test_delete_user(self, test_db_session, sample_user):
        """æµ‹è¯•åˆ é™¤ç”¨æˆ·"""
        service = UserService(test_db_session)
        
        user = service.create_user(**sample_user)
        user_id = user.id
        
        # åˆ é™¤
        service.delete_user(user_id)
        
        # éªŒè¯å·²åˆ é™¤
        assert service.get_user(user_id) is None
    
    def test_user_predictions_relationship(self, test_db_session, sample_user):
        """æµ‹è¯•ç”¨æˆ·-é¢„æµ‹å…³ç³»"""
        service = UserService(test_db_session)
        
        user = service.create_user(**sample_user)
        
        # åˆ›å»ºé¢„æµ‹è®°å½•
        prediction = Prediction(
            user_id=user.id,
            input_text="æµ‹è¯•",
            result="ç»“æœ"
        )
        test_db_session.add(prediction)
        test_db_session.commit()
        
        # éªŒè¯å…³ç³»
        assert len(user.predictions) == 1
        assert user.predictions[0].input_text == "æµ‹è¯•"
```

---

## ğŸ¯ ç¬¬ä¸‰éƒ¨åˆ†ï¼šæµ‹è¯•è¦†ç›–ç‡

### ä¸€ã€Coverageé…ç½®

```ini
# .coveragerc
[run]
source = app
omit =
    */tests/*
    */venv/*
    */__pycache__/*
    */site-packages/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    if TYPE_CHECKING:

precision = 2
show_missing = True

[html]
directory = htmlcov
```

### äºŒã€è¿è¡Œæµ‹è¯•å’Œè¦†ç›–ç‡

```bash
# å®‰è£…ä¾èµ–
pip install pytest pytest-cov pytest-asyncio

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
pytest

# è¿è¡Œå¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pytest --cov=app --cov-report=html --cov-report=term

# åªè¿è¡Œå•å…ƒæµ‹è¯•
pytest tests/test_services.py

# åªè¿è¡Œé›†æˆæµ‹è¯•
pytest tests/test_api_integration.py

# å¹¶è¡Œè¿è¡Œï¼ˆåŠ é€Ÿï¼‰
pytest -n auto

# è¯¦ç»†è¾“å‡º
pytest -v

# å¤±è´¥æ—¶ç«‹å³åœæ­¢
pytest -x

# é‡æ–°è¿è¡Œå¤±è´¥çš„æµ‹è¯•
pytest --lf
```

### ä¸‰ã€æµ‹è¯•æŠ¥å‘Šåˆ†æ

```python
# tests/conftest.pyï¼ˆæ·»åŠ æµ‹è¯•æŠ¥å‘Šï¼‰
import pytest
import json
from datetime import datetime

@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
    outcome = yield
    rep = outcome.get_result()
    
    if rep.when == "call":
        # æ”¶é›†æµ‹è¯•ç»“æœ
        test_result = {
            "name": item.nodeid,
            "outcome": rep.outcome,
            "duration": rep.duration,
            "timestamp": datetime.now().isoformat()
        }
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        with open("test_results.json", "a") as f:
            json.dump(test_result, f)
            f.write("\n")

@pytest.fixture(scope="session", autouse=True)
def test_summary(request):
    """æµ‹è¯•æ‘˜è¦"""
    yield
    
    print("\n" + "="*60)
    print("æµ‹è¯•æ‘˜è¦")
    print("="*60)
    
    # ç»Ÿè®¡
    passed = request.session.testscollected - request.session.testsfailed
    failed = request.session.testsfailed
    
    print(f"æ€»è®¡ï¼š{request.session.testscollected} ä¸ªæµ‹è¯•")
    print(f"é€šè¿‡ï¼š{passed} ä¸ª")
    print(f"å¤±è´¥ï¼š{failed} ä¸ª")
    print(f"æˆåŠŸç‡ï¼š{passed/request.session.testscollected*100:.1f}%")
```

---

## ğŸ“ è¯¾åæ€»ç»“

### æ ¸å¿ƒæ”¶è·

1. **å•å…ƒæµ‹è¯•**
   - PyteståŸºç¡€
   - Fixtureç³»ç»Ÿ
   - MockæŠ€å·§

2. **é›†æˆæµ‹è¯•**
   - APIæµ‹è¯•
   - æ•°æ®åº“æµ‹è¯•
   - ç«¯åˆ°ç«¯æµ‹è¯•

3. **æµ‹è¯•è¦†ç›–ç‡**
   - Coverageå·¥å…·
   - æŠ¥å‘Šåˆ†æ
   - è´¨é‡é—¨ç¦

4. **æœ€ä½³å®è·µ**
   - æµ‹è¯•é‡‘å­—å¡”
   - TDD/BDD
   - CI/CDé›†æˆ

---

## ğŸš€ ä¸‹èŠ‚é¢„å‘Š

ä¸‹ä¸€è¯¾ï¼š**ç¬¬128è¯¾ï¼šDockerå®¹å™¨åŒ– - AIåº”ç”¨æ‰“åŒ…ä¸éƒ¨ç½²**

- Dockerfileç¼–å†™
- å¤šé˜¶æ®µæ„å»º
- Docker Compose
- å®¹å™¨ä¼˜åŒ–

**å®¹å™¨åŒ–éƒ¨ç½²ï¼** ğŸ”¥

---

**ğŸ’ª æµ‹è¯•ä½“ç³»å»ºç«‹å®Œæˆï¼ä»£ç è´¨é‡æœ‰ä¿éšœï¼**

**ä¸‹ä¸€è¯¾è§ï¼** ğŸ‰
