![职业技能体系](./images/skills.svg)
*图：职业技能体系*

# 第134课：需求分析 - 从业务需求到技术方案

> **本课目标**：掌握需求分析方法，设计技术方案
> 
> **核心技能**：需求分析、方案设计、可行性评估、项目规划
> 
> **学习时长**：90分钟

---

## 📖 口播文案（8分钟）

### 🎯 前言

"产品经理来了一句：**'做个AI功能'**

你该怎么办？**直接开干？**

**错！需求分析是第一步！**

**需求分析失败案例：**

```
案例1：某创业公司
需求："做一个类似ChatGPT的产品"
结果：
• 花了3个月
• 做出来没人用
• 产品方向错误
• 公司倒闭

教训：需求太模糊！

案例2：某大厂项目
需求："AI智能客服，能回答所有问题"
结果：
• 投入100万
• 准确率只有30%
• 用户投诉暴增
• 项目下线

教训：期望不现实！

案例3：某外包项目
需求："做一个AI推荐系统"
结果：
• 做了推荐功能
• 但没有冷启动
• 新用户无推荐
• 客户拒绝验收

教训：需求不完整！

需求分析决定成败！
```

**需求分析的5W2H方法：**

```
What（是什么）
• 要做什么功能？
• 解决什么问题？

Why（为什么）
• 为什么要做？
• 业务价值是什么？
• ROI如何？

Who（谁）
• 目标用户是谁？
• 利益相关方是谁？

When（什么时候）
• 什么时候上线？
• 时间节点？

Where（哪里）
• 在哪个场景使用？
• 部署在哪里？

How（怎么做）
• 技术方案是什么？
• 如何实现？

How much（多少）
• 成本多少？
• 资源需求？

全面分析！
```

**业务需求 vs 技术需求：**

```
【业务需求】（What）

来自：产品经理、业务方
语言：业务术语
示例：
"我们希望用户能通过自然语言查询订单信息，
提高客服效率，降低人工成本30%"

特点：
• 关注结果
• 不关注技术
• 有明确指标

【技术需求】（How）

来自：技术团队
语言：技术术语
示例：
"实现NL2SQL系统，使用LLM将自然语言转换为SQL，
支持复杂查询，响应时间<2秒，准确率>90%"

特点：
• 关注实现
• 技术方案
• 性能指标

【需求翻译】

业务需求 → 技术需求

业务："用户能用语音下单"
↓
技术需求：
1. 语音识别（ASR）
2. 意图识别（NLU）
3. 实体提取（NER）
4. 对话管理（DM）
5. 订单系统集成

这是你的价值！
```

**技术方案设计的4个层次：**

```
层次1：功能设计
• 做什么功能
• 用户流程
• 交互设计

层次2：架构设计
• 系统架构
• 模块划分
• 技术选型

层次3：接口设计
• API设计
• 数据格式
• 错误处理

层次4：实施计划
• 开发排期
• 资源分配
• 风险评估

层层递进！
```

**可行性评估的4个维度：**

```
维度1：技术可行性
• 技术是否成熟？
• 是否有现成方案？
• 团队是否掌握？

评估：
✓ RAG技术成熟
✓ LangChain现成框架
✓ 团队有经验
→ 可行

维度2：成本可行性
• 开发成本？
• 运营成本？
• ROI如何？

示例：
开发：2人月 = 10万
运营：API费用 5万/年
收益：节省人工 20万/年
ROI：(20-5)/10 = 150%
→ 值得做

维度3：时间可行性
• 需要多长时间？
• 是否赶得上？

示例：
需求：2个月上线
评估：MVP需要1.5个月
→ 可行

维度4：风险可行性
• 有哪些风险？
• 如何规避？

风险：
- 准确率不达标
- 用户接受度低
- 成本超预算

规避：
- MVP快速验证
- 小范围试点
- 成本上限控制

全面评估！
```

**今天这一课，我要带你：**

**第一部分：需求分析**
- 5W2H方法
- 需求澄清
- 需求文档

**第二部分：技术方案**
- 架构设计
- 技术选型
- 方案对比

**第三部分：可行性评估**
- 四维评估
- 风险分析
- ROI计算

**第四部分：项目规划**
- 里程碑
- 资源计划
- 风险预案

从需求到方案！"

---

## 📚 第一部分：需求分析实战

### 一、需求分析模板

```markdown
# AI项目需求分析文档

## 1. 项目概述


![需求分析](./images/requirements.svg)
*图：需求分析*

### 1.1 项目背景（Why）
- **业务痛点**：客服团队每天处理5000+重复问题，响应速度慢，成本高
- **业务目标**：降低客服成本30%，提高响应速度50%
- **预期收益**：年节省人工成本100万元

### 1.2 项目范围（What）
- **做什么**：智能客服问答系统
- **不做什么**：情感分析、多轮复杂对话
- **版本规划**：
  - V1.0：FAQ问答（MVP）
  - V2.0：订单查询
  - V3.0：多轮对话

## 2. 用户分析（Who）

### 2.1 目标用户
- **用户画像**：
  - 年龄：20-40岁
  - 场景：售前咨询、售后服务
  - 频次：每天1000+次咨询
  
- **用户痛点**：
  - 人工客服等待时间长
  - 非工作时间无法咨询
  - 问题得不到及时解答

### 2.2 利益相关方
- **客服团队**：减少重复工作
- **运营团队**：提高服务质量
- **技术团队**：实现和维护
- **管理层**：降本增效

## 3. 功能需求（What & How）

### 3.1 核心功能
1. **FAQ问答**
   - 用户输入问题
   - 系统返回答案
   - 准确率>90%
   - 响应时间<2秒

2. **相似问题推荐**
   - 如果无准确答案
   - 推荐3个相似问题
   - 相似度>0.7

3. **人工转接**
   - 识别复杂问题
   - 自动转人工
   - 转接率<20%

### 3.2 非功能需求
- **性能**：并发1000 QPS，P95<2s
- **可用性**：99.9%可用性
- **安全性**：数据加密，访问控制
- **可扩展性**：支持10万+FAQ

## 4. 技术需求（How）

### 4.1 技术方案
- **技术选型**：RAG架构
- **向量库**：Chroma
- **LLM**：OpenAI GPT-4
- **框架**：LangChain
- **后端**：FastAPI
- **前端**：React

### 4.2 系统架构
```
用户 → Web界面 → API网关 → RAG系统 → 向量库
                              ↓
                            LLM API
```

### 4.3 接口设计
```
POST /api/v1/chat
Request:
{
  "question": "如何退款？",
  "session_id": "abc123"
}

Response:
{
  "answer": "退款流程如下...",
  "confidence": 0.95,
  "sources": ["doc1", "doc2"]
}
```

## 5. 时间规划（When）

### 5.1 里程碑
- **Week 1-2**：需求调研、方案设计
- **Week 3-4**：MVP开发
- **Week 5**：测试优化
- **Week 6**：试点上线
- **Week 7-8**：全量推广

### 5.2 关键时间节点
- **需求评审**：2024-01-15
- **技术评审**：2024-01-20
- **MVP上线**：2024-02-15
- **正式发布**：2024-03-01

## 6. 资源需求（How much）

### 6.1 人力资源
- **后端开发**：2人
- **前端开发**：1人
- **算法工程师**：1人
- **测试工程师**：1人
- **产品经理**：0.5人

### 6.2 成本预算
- **开发成本**：5人月 × 2万 = 10万
- **云服务**：1万/月
- **API费用**：OpenAI 5000元/月
- **总预算**：15万

### 6.3 ROI分析
- **年成本**：15万（开发）+ 6万（运营）= 21万
- **年收益**：节省人工100万
- **ROI**：(100-21)/21 = 376%

## 7. 风险分析

### 7.1 技术风险
- **风险**：准确率不达标
- **概率**：中
- **影响**：高
- **应对**：增加训练数据，调优模型

### 7.2 业务风险
- **风险**：用户接受度低
- **概率**：低
- **影响**：中
- **应对**：小范围试点，收集反馈

### 7.3 成本风险
- **风险**：API费用超预算
- **概率**：中
- **影响**：中
- **应对**：设置费用上限，考虑本地部署

## 8. 成功标准

### 8.1 定量指标
- ✓ 准确率>90%
- ✓ 响应时间P95<2s
- ✓ 自动解决率>80%
- ✓ 用户满意度>4.0/5.0

### 8.2 定性指标
- ✓ 客服团队满意
- ✓ 用户体验良好
- ✓ 运维成本可控

## 9. 附录

### 9.1 参考资料
- GDPR合规要求
- 公司技术规范
- 竞品分析报告

### 9.2 词汇表
- **RAG**：检索增强生成
- **FAQ**：常见问题
- **QPS**：每秒查询数
```

---

## 💻 第二部分：技术方案设计

### 一、方案对比模板

```markdown
# 技术方案对比

## 方案1：基于规则的FAQ匹配

### 优势
✓ 实现简单
✓ 成本低
✓ 可控性强

### 劣势
✗ 准确率低（60-70%）
✗ 维护成本高
✗ 无法处理变化表述

### 成本
- 开发：1人月
- 运营：几乎为0

### 适用场景
- FAQ数量少（<100）
- 问题表述固定
- 预算有限

---

## 方案2：基于传统NLP的相似度匹配

### 优势
✓ 准确率中等（75-85%）
✓ 成本适中
✓ 本地部署

### 劣势
✗ 需要大量训练数据
✗ 泛化能力弱
✗ 维护成本较高

### 成本
- 开发：2人月
- 运营：服务器5000元/月

### 适用场景
- FAQ数量中等（100-1000）
- 有历史数据
- 可接受一定错误率

---

## 方案3：基于LLM的RAG系统（推荐）

### 优势
✓ 准确率高（90-95%）
✓ 泛化能力强
✓ 开发效率高
✓ 易于维护

### 劣势
✗ API费用较高
✗ 依赖第三方服务
✗ 响应时间稍长

### 成本
- 开发：1.5人月
- 运营：API 5000元/月 + 服务器 3000元/月

### 适用场景
- FAQ数量大（1000+）
- 要求高准确率
- 预算充足

---

## 方案对比表

| 维度 | 规则匹配 | NLP相似度 | LLM RAG |
|------|----------|-----------|---------|
| 准确率 | 60-70% | 75-85% | 90-95% |
| 开发周期 | 2周 | 1个月 | 3周 |
| 开发成本 | 1万 | 4万 | 3万 |
| 运营成本 | 0 | 5k/月 | 8k/月 |
| 维护成本 | 高 | 中 | 低 |
| 扩展性 | 差 | 中 | 好 |
| 技术风险 | 低 | 中 | 中 |

## 推荐方案：LLM RAG

### 理由
1. 准确率最高，满足业务要求
2. 开发周期适中
3. 维护成本低
4. 扩展性好，可持续迭代

### 风险应对
1. API费用：设置月度上限
2. 依赖第三方：准备备用方案（本地模型）
3. 响应时间：缓存+异步处理
```

---

## 🎯 第三部分：项目规划

### 一、项目计划模板

```python
# project_plan.py
from datetime import datetime, timedelta
from typing import List, Dict
from enum import Enum

class TaskStatus(str, Enum):
    """任务状态"""
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"

class Task:
    """任务"""
    
    def __init__(
        self,
        id: str,
        name: str,
        owner: str,
        duration_days: int,
        dependencies: List[str] = None,
        status: TaskStatus = TaskStatus.NOT_STARTED
    ):
        self.id = id
        self.name = name
        self.owner = owner
        self.duration_days = duration_days
        self.dependencies = dependencies or []
        self.status = status
        self.start_date = None
        self.end_date = None

class ProjectPlan:
    """项目计划"""
    
    def __init__(self, project_name: str, start_date: datetime):
        self.project_name = project_name
        self.start_date = start_date
        self.tasks: Dict[str, Task] = {}
    
    def add_task(self, task: Task):
        """添加任务"""
        self.tasks[task.id] = task
    
    def calculate_schedule(self):
        """计算排期"""
        
        # 拓扑排序计算开始时间
        completed = set()
        
        while len(completed) < len(self.tasks):
            for task_id, task in self.tasks.items():
                if task_id in completed:
                    continue
                
                # 检查依赖是否完成
                deps_completed = all(
                    dep in completed
                    for dep in task.dependencies
                )
                
                if deps_completed:
                    # 计算开始时间
                    if task.dependencies:
                        # 最晚依赖的结束时间
                        max_end = max(
                            self.tasks[dep].end_date
                            for dep in task.dependencies
                        )
                        task.start_date = max_end + timedelta(days=1)
                    else:
                        task.start_date = self.start_date
                    
                    task.end_date = task.start_date + timedelta(
                        days=task.duration_days - 1
                    )
                    
                    completed.add(task_id)
    
    def print_gantt(self):
        """打印甘特图"""
        
        print(f"\n{'='*80}")
        print(f"项目：{self.project_name}")
        print(f"开始日期：{self.start_date.strftime('%Y-%m-%d')}")
        print(f"{'='*80}\n")
        
        print(f"{'任务':<20} {'负责人':<10} {'工期':<6} {'开始日期':<12} {'结束日期':<12} {'状态':<10}")
        print("-" * 80)
        
        # 按开始时间排序
        sorted_tasks = sorted(
            self.tasks.values(),
            key=lambda t: t.start_date
        )
        
        for task in sorted_tasks:
            print(
                f"{task.name:<20} "
                f"{task.owner:<10} "
                f"{task.duration_days:<6} "
                f"{task.start_date.strftime('%Y-%m-%d'):<12} "
                f"{task.end_date.strftime('%Y-%m-%d'):<12} "
                f"{task.status.value:<10}"
            )
        
        # 项目总工期
        project_end = max(t.end_date for t in self.tasks.values())
        project_duration = (project_end - self.start_date).days + 1
        
        print("-" * 80)
        print(f"项目结束日期：{project_end.strftime('%Y-%m-%d')}")
        print(f"项目总工期：{project_duration}天")
        print(f"{'='*80}\n")

# 使用示例：智能客服项目计划
plan = ProjectPlan(
    project_name="智能客服问答系统",
    start_date=datetime(2024, 1, 15)
)

# 添加任务
tasks = [
    Task("T1", "需求调研", "产品", 3),
    Task("T2", "技术方案设计", "架构师", 2, ["T1"]),
    Task("T3", "数据准备", "算法", 5, ["T2"]),
    Task("T4", "RAG系统开发", "后端", 10, ["T2"]),
    Task("T5", "前端开发", "前端", 8, ["T2"]),
    Task("T6", "联调测试", "测试", 3, ["T4", "T5"]),
    Task("T7", "性能优化", "后端", 2, ["T6"]),
    Task("T8", "试点上线", "运维", 1, ["T7"]),
    Task("T9", "全量发布", "运维", 1, ["T8"]),
]

for task in tasks:
    plan.add_task(task)

# 计算排期
plan.calculate_schedule()

# 打印甘特图
plan.print_gantt()
```

---

## 📝 课后总结

### 核心收获

1. **需求分析**
   - 5W2H方法
   - 需求澄清
   - 需求文档

2. **技术方案**
   - 架构设计
   - 方案对比
   - 技术选型

3. **可行性评估**
   - 技术可行性
   - 成本可行性
   - 时间可行性
   - 风险可行性

4. **项目规划**
   - 任务分解
   - 排期计划
   - 资源分配

---

## 🚀 下节预告

下一课：**第135课：技术选型 - 如何选择合适的技术栈**

- 选型原则
- 技术对比
- 决策模型
- 避坑指南

**做出正确选择！** 🔥

---

**💪 需求分析能力提升！从需求到方案！**

**职业技能模块开启！** 🎉

**下一课见！** 💼
