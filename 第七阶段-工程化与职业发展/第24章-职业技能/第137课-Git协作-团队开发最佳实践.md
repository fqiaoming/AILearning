![职业技能体系](./images/skills.svg)
*图：职业技能体系*

# 第137课：Git协作 - 团队开发最佳实践

> **本课目标**：掌握Git团队协作流程，提升协作效率
> 
> **核心技能**：Git工作流、分支策略、Code Review、冲突解决
> 
> **学习时长**：90分钟

---

## 📖 口播文案（8分钟）
![Requirements](./images/requirements.svg)
*图：Requirements*


### 🎯 前言

"多人协作开发，**代码乱成一团！**

**Git用不好=效率灾难！**

**Git使用混乱的后果：**

```
场景1：分支混乱
• 每个人随便建分支
• 分支命名混乱
• 不知道哪个分支是什么
• 合并冲突不断
• 代码丢失

结果：开发效率低下

场景2：提交混乱
• 提交信息随便写："修复bug"、"更新"
• 一次提交改了100个文件
• 无法回溯问题
• Code Review困难

结果：维护困难

场景3：代码冲突
• 多人改同一文件
• 冲突不会解决
• 误删他人代码
• 功能被覆盖

结果：重大事故

场景4：直接push master
• 未经测试的代码
• 直接push到主分支
• 生产环境故障

结果：服务宕机

规范Git=高效协作！
```

**Git工作流对比：**

```
【Git Flow】（经典，复杂）

分支：
• master：生产环境
• develop：开发主分支
• feature/*：功能分支
• release/*：发布分支
• hotfix/*：紧急修复

优势：
✓ 流程清晰
✓ 适合发布周期长的项目

劣势：
✗ 分支太多，复杂
✗ 合并频繁

适用：大型项目、发布周期长

【GitHub Flow】（简单，推荐）

分支：
• main：主分支
• feature/*：功能分支

流程：
1. 从main创建分支
2. 开发+提交
3. 发起PR
4. Code Review
5. 合并到main
6. 部署

优势：
✓ 简单易懂
✓ 持续部署友好

劣势：
✗ 不适合复杂发布

适用：Web应用、敏捷开发

【GitLab Flow】（折中）

分支：
• main：主分支
• feature/*：功能分支
• production：生产环境

流程：
main → staging → production

优势：
✓ 平衡简单与控制

适用：中等规模项目

推荐：GitHub Flow（最简单有效）
```

**提交信息规范（Conventional Commits）：**

```
【格式】
<type>(<scope>): <subject>

<body>

<footer>

【Type类型】
• feat: 新功能
• fix: 修复bug
• docs: 文档
• style: 格式（不影响代码运行）
• refactor: 重构
• test: 测试
• chore: 构建/工具

【示例】

❌ 差：
"修复bug"
"更新代码"
"临时提交"

✓ 好：
"feat(auth): 添加JWT认证功能"
"fix(api): 修复用户登录失败的问题"
"docs(readme): 更新安装文档"
"refactor(rag): 优化检索算法性能"

【完整示例】

feat(rag): 添加混合检索功能

实现向量检索+BM25关键词检索的混合方案，
并使用RRF算法融合结果。

性能提升：
- 准确率从85%提升到92%
- 召回率从80%提升到88%

Closes #123

---

清晰明了！
```

**Code Review的价值：**

```
【为什么要Code Review？】

价值1：发现Bug
• 4个眼睛>2个眼睛
• 逻辑错误
• 边界情况
• 性能问题

价值2：知识共享
• 了解他人代码
• 学习新技巧
• 统一风格

价值3：提高质量
• 代码规范
• 最佳实践
• 架构优化

价值4：减少技术债
• 及时重构
• 避免临时方案
• 保持代码健康

【Review什么？】

✓ 功能正确性
✓ 代码可读性
✓ 性能
✓ 安全性
✓ 测试覆盖
✓ 文档完整性

【Review不是找茬】

好的Review：
✓ 建设性意见
✓ 具体建议
✓ 赞美好代码

差的Review：
✗ "这代码写得什么玩意"
✗ "重写吧"
✗ 只批评不建议

尊重为先！
```

**今天这一课，我要带你：**

**第一部分：Git工作流**
- GitHub Flow
- 分支策略
- 提交规范

**第二部分：团队协作**
- Pull Request
- Code Review
- 协作流程

**第三部分：冲突解决**
- 冲突原因
- 解决方法
- 预防策略

**第四部分：最佳实践**
- 提交技巧
- 分支管理
- 团队规范

高效协作！"

---

## 📚 第一部分：Git工作流实战

### 一、GitHub Flow标准流程

```bash
# ============ 1. 从main创建功能分支 ============

# 切换到main分支
git checkout main

# 拉取最新代码
git pull origin main

# 创建新分支（命名规范：类型/描述）
git checkout -b feature/add-hybrid-search

# ============ 2. 开发+提交 ============

# 开发代码...
# 编辑文件 app/rag/hybrid_search.py

# 查看修改
git status
git diff

# 添加修改
git add app/rag/hybrid_search.py

# 提交（遵循Conventional Commits）
git commit -m "feat(rag): 添加混合检索功能

实现向量检索+BM25的混合方案，使用RRF融合。

- 添加BM25检索器
- 实现RRF融合算法
- 添加单元测试

性能：准确率提升7%"

# ============ 3. 推送到远程 ============

# 首次推送，建立跟踪
git push -u origin feature/add-hybrid-search

# 后续推送
git push

# ============ 4. 发起Pull Request ============

# 在GitHub上：
# 1. 点击 "New Pull Request"
# 2. 选择 base: main <- compare: feature/add-hybrid-search
# 3. 填写PR标题和描述
# 4. 选择Reviewer
# 5. 创建PR

# ============ 5. Code Review ============

# Reviewer在GitHub上：
# 1. 查看Files changed
# 2. 添加评论
# 3. Approve或Request Changes

# 如果需要修改：
# 在本地继续开发
git add .
git commit -m "fix(rag): 修复Review意见的问题"
git push

# PR会自动更新

# ============ 6. 合并 ============

# Reviewer批准后，在GitHub上：
# 1. 点击 "Merge Pull Request"
# 2. 选择合并方式：
#    - Merge commit（保留所有提交）
#    - Squash and merge（合并为一个提交，推荐）
#    - Rebase and merge（变基合并）
# 3. 确认合并

# ============ 7. 清理分支 ============

# 删除远程分支（GitHub自动提示）
# 删除本地分支
git checkout main
git pull origin main
git branch -d feature/add-hybrid-search

# ============ 完整流程图 ============
#
#   main ───────────────┬──────────────▶
#                       │              ╱
#   feature ────────────┼─────────────▶
#                       │
#                    创建分支    PR合并
```

### 二、提交规范工具

```python
# commit_template.py
"""Git提交信息模板生成器"""

from enum import Enum
from typing import Optional, List

class CommitType(str, Enum):
    """提交类型"""
    FEAT = "feat"  # 新功能
    FIX = "fix"  # 修复
    DOCS = "docs"  # 文档
    STYLE = "style"  # 格式
    REFACTOR = "refactor"  # 重构
    TEST = "test"  # 测试
    CHORE = "chore"  # 构建/工具

class CommitMessage:
    """提交信息"""
    
    def __init__(
        self,
        type: CommitType,
        scope: str,
        subject: str,
        body: Optional[str] = None,
        footer: Optional[str] = None
    ):
        self.type = type
        self.scope = scope
        self.subject = subject
        self.body = body
        self.footer = footer
    
    def generate(self) -> str:
        """生成提交信息"""
        # 标题
        message = f"{self.type.value}({self.scope}): {self.subject}"
        
        # 正文
        if self.body:
            message += f"\n\n{self.body}"
        
        # 尾部
        if self.footer:
            message += f"\n\n{self.footer}"
        
        return message
    
    @classmethod
    def from_interactive(cls):
        """交互式创建"""
        print("="*60)
        print("Git提交信息生成器")
        print("="*60)
        print()
        
        # 类型
        print("选择提交类型：")
        for i, t in enumerate(CommitType, 1):
            print(f"  {i}. {t.value}")
        type_idx = int(input("请输入数字: ")) - 1
        type_ = list(CommitType)[type_idx]
        
        # 范围
        scope = input("范围（如：auth, rag, api）: ")
        
        # 主题
        subject = input("简短描述（<50字符）: ")
        
        # 正文
        print("详细描述（可选，输入空行结束）:")
        body_lines = []
        while True:
            line = input()
            if not line:
                break
            body_lines.append(line)
        body = "\n".join(body_lines) if body_lines else None
        
        # 尾部
        issue_id = input("关联Issue ID（可选）: ")
        footer = f"Closes #{issue_id}" if issue_id else None
        
        return cls(type_, scope, subject, body, footer)

# 使用示例
if __name__ == "__main__":
    # 方式1：直接创建
    commit = CommitMessage(
        type=CommitType.FEAT,
        scope="rag",
        subject="添加混合检索功能",
        body="实现向量检索+BM25的混合方案\n\n性能提升：\n- 准确率: 85% → 92%\n- 召回率: 80% → 88%",
        footer="Closes #123"
    )
    
    print(commit.generate())
    print()
    
    # 方式2：交互式
    # commit = CommitMessage.from_interactive()
    # print("\n生成的提交信息：")
    # print("="*60)
    # print(commit.generate())
```

---

## 💻 第二部分：Pull Request最佳实践

### 一、优秀PR模板

```markdown
# Pull Request模板

## 📝 变更说明

<!-- 简要说明这个PR做了什么 -->

添加了混合检索功能，结合向量检索和BM25关键词检索，使用RRF算法融合结果。

## 🎯 相关Issue

Closes #123

## 📸 截图/演示

<!-- 如果有UI变更，提供截图；如果是功能，提供使用示例 -->

```python
# 使用示例
retriever = HybridRetriever(
    vector_weight=0.7,
    bm25_weight=0.3
)
results = retriever.search("查询文本", top_k=5)
```

## ✅ 变更类型

- [x] 新功能
- [ ] Bug修复
- [ ] 重构
- [ ] 文档更新
- [ ] 性能优化

## 🧪 测试

- [x] 添加了单元测试
- [x] 所有测试通过
- [x] 代码覆盖率 >80%

## 📋 检查清单

- [x] 代码遵循项目规范
- [x] 添加了必要的注释
- [x] 更新了相关文档
- [x] 没有产生新的警告
- [x] 通过了所有检查

## 📊 性能影响

<!-- 如果涉及性能变化，说明影响 -->

| 指标 | 之前 | 之后 | 变化 |
|------|------|------|------|
| 准确率 | 85% | 92% | +7% |
| 召回率 | 80% | 88% | +8% |
| 响应时间 | 150ms | 180ms | +30ms |

准确率显著提升，响应时间增加可接受。

## 💭 额外说明

<!-- 其他需要说明的内容 -->

- 使用了新的BM25库，需要更新依赖
- 配置文件新增了权重参数

## 👀 Reviewer注意

<!-- 提醒Reviewer重点关注的部分 -->

- 重点关注 `app/rag/hybrid_search.py` 的融合算法
- 确认参数配置是否合理

---

/cc @reviewer1 @reviewer2
```

### 二、Code Review检查清单

```python
# code_review_checklist.py
"""Code Review检查清单"""

from dataclasses import dataclass
from typing import List
from enum import Enum

class ReviewCategory(str, Enum):
    """Review类别"""
    FUNCTIONALITY = "功能正确性"
    CODE_QUALITY = "代码质量"
    PERFORMANCE = "性能"
    SECURITY = "安全性"
    TESTING = "测试"
    DOCUMENTATION = "文档"

@dataclass
class ReviewItem:
    """Review项目"""
    category: ReviewCategory
    question: str
    importance: str  # 高/中/低

# Code Review检查清单
REVIEW_CHECKLIST: List[ReviewItem] = [
    # 功能正确性
    ReviewItem(
        ReviewCategory.FUNCTIONALITY,
        "功能是否符合需求？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.FUNCTIONALITY,
        "是否处理了边界情况？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.FUNCTIONALITY,
        "错误处理是否完善？",
        "高"
    ),
    
    # 代码质量
    ReviewItem(
        ReviewCategory.CODE_QUALITY,
        "代码是否易读易懂？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.CODE_QUALITY,
        "命名是否清晰？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.CODE_QUALITY,
        "是否遵循项目规范？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.CODE_QUALITY,
        "是否有重复代码？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.CODE_QUALITY,
        "函数是否过长（>50行）？",
        "中"
    ),
    
    # 性能
    ReviewItem(
        ReviewCategory.PERFORMANCE,
        "是否有性能问题？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.PERFORMANCE,
        "数据库查询是否优化？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.PERFORMANCE,
        "是否有N+1查询？",
        "高"
    ),
    
    # 安全性
    ReviewItem(
        ReviewCategory.SECURITY,
        "是否有SQL注入风险？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.SECURITY,
        "输入是否经过验证？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.SECURITY,
        "敏感信息是否加密？",
        "高"
    ),
    
    # 测试
    ReviewItem(
        ReviewCategory.TESTING,
        "是否添加了测试？",
        "高"
    ),
    ReviewItem(
        ReviewCategory.TESTING,
        "测试覆盖率是否足够？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.TESTING,
        "测试是否有效？",
        "高"
    ),
    
    # 文档
    ReviewItem(
        ReviewCategory.DOCUMENTATION,
        "是否添加了必要的注释？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.DOCUMENTATION,
        "是否更新了文档？",
        "中"
    ),
    ReviewItem(
        ReviewCategory.DOCUMENTATION,
        "API是否有文档？",
        "高"
    ),
]

def print_checklist():
    """打印检查清单"""
    print("="*80)
    print("Code Review检查清单")
    print("="*80)
    print()
    
    # 按类别分组
    by_category = {}
    for item in REVIEW_CHECKLIST:
        if item.category not in by_category:
            by_category[item.category] = []
        by_category[item.category].append(item)
    
    # 打印
    for category, items in by_category.items():
        print(f"## {category.value}")
        print()
        for item in items:
            importance = "🔴" if item.importance == "高" else "🟡" if item.importance == "中" else "🟢"
            print(f"  {importance} {item.question}")
        print()

if __name__ == "__main__":
    print_checklist()
```

---

## 🎯 第三部分：冲突解决

### 一、冲突原因与解决

```bash
# ============ 冲突场景 ============

# 场景：两个人同时修改了同一个文件的同一部分

# 开发者A：
git checkout -b feature/a
# 修改 config.py 第10行
git commit -m "feat: 修改配置"
git push origin feature/a

# 开发者B：
git checkout -b feature/b
# 也修改 config.py 第10行（不同的修改）
git commit -m "feat: 更新配置"
git push origin feature/b

# 开发者A的PR先合并到main

# 开发者B尝试合并时 → 冲突！

# ============ 解决冲突 ============

# 方式1：使用rebase（推荐）

# 1. 更新main
git checkout main
git pull origin main

# 2. rebase你的分支
git checkout feature/b
git rebase main

# 3. 如果有冲突，Git会提示
# <<<<<<< HEAD
# 这是main的内容
# =======
# 这是你的内容
# >>>>>>> feature/b

# 4. 手动解决冲突
# 编辑文件，保留正确的内容
# 删除冲突标记

# 5. 标记为已解决
git add config.py

# 6. 继续rebase
git rebase --continue

# 7. 推送（需要强制推送）
git push origin feature/b --force-with-lease

# 方式2：使用merge

# 1. 合并main到你的分支
git checkout feature/b
git merge main

# 2. 解决冲突（同上）
git add config.py
git commit -m "merge: 解决冲突"

# 3. 推送
git push origin feature/b

# ============ 推荐工具 ============

# VS Code内置冲突解决工具
# 会显示：
# - Accept Current Change（保留你的）
# - Accept Incoming Change（保留对方的）
# - Accept Both Changes（都保留）
# - Compare Changes（对比）

# ============ 预防冲突 ============

# 1. 小步提交，频繁合并
# 2. 及时同步main
# 3. 功能分支尽快合并
# 4. 沟通协调，避免同时改同一文件
```

---

## 📝 课后总结

### 核心收获

1. **Git工作流**
   - GitHub Flow
   - 分支策略
   - 提交规范

2. **团队协作**
   - Pull Request
   - Code Review
   - 协作流程

3. **冲突解决**
   - Rebase vs Merge
   - 冲突处理
   - 预防策略

4. **最佳实践**
   - 提交规范
   - PR模板
   - Review检查清单

---

## 🚀 下节预告

下一课：**第138课：简历准备 - 如何写出吸引人的技术简历**

- 简历结构
- 项目描述
- 技能清单
- 避坑指南

**写出好简历！** 🔥

---

**💪 Git协作能力提升！高效团队协作！**

**下一课见！** 🎉
