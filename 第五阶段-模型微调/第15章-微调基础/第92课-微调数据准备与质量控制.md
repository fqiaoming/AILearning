![模型微调流程](./images/finetune.svg)
*图：模型微调流程*

# 第92课：微调数据准备与质量控制

> **本课目标**：掌握高质量微调数据的准备、清洗和评估方法
> 
> **核心技能**：数据格式、数据清洗、质量评估、数据增强
> 
> **学习时长**：90分钟

---

## 📖 口播文案（6分钟）
![Hyperparams](./images/hyperparams.svg)
*图：Hyperparams*


### 🎯 前言

"上节课我们学习了微调的理论基础。

今天要讲一个更重要的话题：**微调数据准备！**

在AI领域有句话：**Garbage In, Garbage Out**

**垃圾数据 → 垃圾模型！**

再好的算法，遇到差数据也白搭！

**真实案例：数据质量的威力**

**案例1：同样的模型，不同的数据**
```
场景：医疗问答微调

团队A：
• 数据量：10000条
• 数据来源：网上爬取
• 清洗程度：未清洗
• 微调结果：准确率65%  ❌

团队B：
• 数据量：3000条
• 数据来源：专家标注
• 清洗程度：严格清洗
• 微调结果：准确率92%  ✅

差距：27%！
数据质量 > 数据数量！
```

**案例2：数据格式错误导致失败**
```
某公司微调项目：

错误数据格式：
{
  "input": "...",
  "output": "..."  # 混乱的格式
}

结果：
• 训练loss不下降
• 模型输出混乱
• 浪费3天时间

修正后：
统一格式 → 立即见效！
```

**案例3：数据偏见导致问题**
```
客服机器人微调：

原始数据：
• 90%简单问题
• 10%复杂问题

结果：
模型只会回答简单问题
遇到复杂问题就崩溃

解决：
平衡数据分布 → 全面能力
```

**今天我要告诉你：如何准备完美的微调数据！**

**微调数据的4大要素：**

**要素1：格式正确**
```
错误格式：
各种各样的格式
模型无法理解

正确格式：
统一、规范、一致
模型快速学习

就像：
乱码 vs 整齐的教科书
```

**要素2：质量高**
```
高质量数据：
• 准确无误
• 逻辑清晰
• 语言流畅
• 信息完整

低质量数据：
• 错误百出
• 逻辑混乱
• 语言生硬
• 信息缺失

质量决定上限！
```

**要素3：数量足**
```
太少：
模型学不会
容易过拟合

太多：
训练时间长
成本高

合适的量：
• 简单任务：500-2000条
• 中等任务：2000-5000条
• 复杂任务：5000-20000条

按需准备！
```

**要素4：分布均衡**
```
不均衡：
• 90%类型A
• 10%类型B

结果：
只会A，不会B

均衡：
• 50%类型A
• 50%类型B

结果：
都会！
```

**微调数据的标准格式：**

**格式1：对话格式（最常用）**
```json
{
  "messages": [
    {
      "role": "system",
      "content": "你是一个医疗助手"
    },
    {
      "role": "user",
      "content": "头痛怎么办？"
    },
    {
      "role": "assistant",
      "content": "头痛的原因很多..."
    }
  ]
}

OpenAI标准格式
最推荐！
```

**格式2：指令格式**
```json
{
  "instruction": "翻译成英文",
  "input": "你好世界",
  "output": "Hello World"
}

Alpaca格式
适合指令任务
```

**格式3：问答格式**
```json
{
  "question": "Python如何读取文件？",
  "answer": "使用open()函数..."
}

简单直接
适合QA任务
```

**数据准备的5大步骤：**

**步骤1：数据收集（3种来源）**
```
来源1：现有数据
• 企业内部数据
• 历史对话记录
• 文档资料

来源2：公开数据集
• Hugging Face
• GitHub
• 论文数据集

来源3：人工标注
• 专家标注
• 众包标注
• 自己标注

优先级：现有 > 公开 > 标注
```

**步骤2：数据清洗（6大操作）**
```
清洗1：去重
• 完全重复 → 删除
• 高度相似 → 合并

清洗2：格式统一
• 统一换行符
• 统一编码
• 统一标点

清洗3：错误修正
• 拼写错误
• 语法错误
• 标注错误

清洗4：噪声过滤
• 乱码
• 无意义内容
• HTML标签

清洗5：长度控制
• 太短 → 删除/合并
• 太长 → 截断/分割

清洗6：敏感信息脱敏
• 电话号码
• 身份证号
• 地址信息
```

**步骤3：数据验证（4个检查）**
```
检查1：格式验证
所有数据格式一致？

检查2：质量抽查
随机抽取100条检查

检查3：统计分析
• 长度分布
• 类别分布
• 关键词统计

检查4：边界测试
• 最短的数据正常吗？
• 最长的数据正常吗？
• 特殊字符处理了吗？
```

**步骤4：数据增强（3种方法）**
```
方法1：回译（Back Translation）
中文 → 英文 → 中文
产生变体

方法2：同义词替换
"开心" → "高兴"
增加多样性

方法3：LLM生成
用GPT-4生成类似数据
快速扩充

注意：增强数据要审核！
```

**步骤5：数据分割（标准比例）**
```
训练集：80%
• 用于训练模型

验证集：10%
• 调整超参数
• 防止过拟合

测试集：10%
• 最终评估
• 不参与训练

重要：测试集绝对不能泄露！
```

**数据质量的评估标准：**

```
【评分标准】

准确性（40分）：
• 事实正确
• 逻辑一致
• 无明显错误

完整性（20分）：
• 信息完整
• 不缺关键内容
• 上下文清晰

流畅性（20分）：
• 语言自然
• 表达清晰
• 无语病

相关性（20分）：
• 问答匹配
• 主题一致
• 不偏题

总分≥80：优秀
总分60-79：合格
总分<60：需改进
```

**常见数据问题与解决：**

**问题1：数据量不足**
```
解决方案：
1. 数据增强（回译、改写）
2. Few-shot学习
3. 使用更大的预训练模型
4. 降低任务复杂度
```

**问题2：数据不均衡**
```
解决方案：
1. 上采样（少数类）
2. 下采样（多数类）
3. 生成合成数据
4. 调整loss权重
```

**问题3：标注不一致**
```
解决方案：
1. 制定详细标注指南
2. 多人标注+投票
3. 专家审核
4. 一致性检查
```

**今天这一课，我要带你：**

**第一部分：数据格式详解**
- 3种标准格式
- 格式转换
- 验证工具

**第二部分：数据清洗实战**
- 6大清洗操作
- Python实现
- 自动化流程

**第三部分：质量评估体系**
- 评分标准
- 自动评估
- 人工审核

**第四部分：数据增强技术**
- 3种增强方法
- 实现代码
- 效果对比

**第五部分：最佳实践**
- 完整流程
- 工具推荐
- 避坑指南

学完这一课，你将掌握数据准备全流程！

准备好了吗？让我们开始！"

---

### 💡 核心理念

```
【数据质量 > 数据数量】

宁要：
• 1000条高质量数据

不要：
• 10000条垃圾数据

【数据准备是一门艺术】

需要：
• 细心
• 耐心
• 专业知识
• 不断迭代

值得投入时间！
```

---

## 📚 第一部分：数据格式详解

### 一、标准格式定义

```python
from typing import List, Dict
from pydantic import BaseModel, validator
import json

# 格式1：OpenAI对话格式（推荐）
class Message(BaseModel):
    """单条消息"""
    role: str  # system, user, assistant
    content: str
    
    @validator('role')
    def validate_role(cls, v):
        if v not in ['system', 'user', 'assistant']:
            raise ValueError('role必须是system、user或assistant')
        return v

class ChatFormat(BaseModel):
    """对话格式数据"""
    messages: List[Message]
    
    def to_dict(self) -> Dict:
        return {
            'messages': [
                {'role': msg.role, 'content': msg.content}
                for msg in self.messages
            ]
        }

# 格式2：Alpaca指令格式
class AlpacaFormat(BaseModel):
    """Alpaca格式数据"""
    instruction: str
    input: str = ""  # 可选
    output: str
    
    def to_dict(self) -> Dict:
        data = {
            'instruction': self.instruction,
            'output': self.output
        }
        if self.input:
            data['input'] = self.input
        return data

# 格式3：简单问答格式
class QAFormat(BaseModel):
    """问答格式数据"""
    question: str
    answer: str
    context: str = ""  # 可选的上下文
    
    def to_dict(self) -> Dict:
        data = {
            'question': self.question,
            'answer': self.answer
        }
        if self.context:
            data['context'] = self.context
        return data

# 演示：创建标准格式数据
def demo_formats():
    """演示三种格式"""
    
    print("="*60)
    print("微调数据标准格式演示")
    print("="*60)
    
    # 格式1：对话格式
    print("\n【格式1：OpenAI对话格式】")
    chat_data = ChatFormat(
        messages=[
            Message(role="system", content="你是一个Python编程助手"),
            Message(role="user", content="如何读取文件？"),
            Message(role="assistant", content="使用open()函数可以读取文件...")
        ]
    )
    print(json.dumps(chat_data.to_dict(), ensure_ascii=False, indent=2))
    
    # 格式2：Alpaca格式
    print("\n【格式2：Alpaca指令格式】")
    alpaca_data = AlpacaFormat(
        instruction="将以下文本翻译成英文",
        input="你好，世界！",
        output="Hello, World!"
    )
    print(json.dumps(alpaca_data.to_dict(), ensure_ascii=False, indent=2))
    
    # 格式3：问答格式
    print("\n【格式3：简单问答格式】")
    qa_data = QAFormat(
        question="Python中如何定义函数？",
        answer="使用def关键字定义函数，例如：def my_function():"
    )
    print(json.dumps(qa_data.to_dict(), ensure_ascii=False, indent=2))

demo_formats()
```

### 二、格式转换工具

```python
class FormatConverter:
    """数据格式转换器"""
    
    @staticmethod
    def qa_to_chat(qa_data: Dict) -> Dict:
        """问答格式 → 对话格式"""
        
        return {
            'messages': [
                {'role': 'user', 'content': qa_data['question']},
                {'role': 'assistant', 'content': qa_data['answer']}
            ]
        }
    
    @staticmethod
    def alpaca_to_chat(alpaca_data: Dict) -> Dict:
        """Alpaca格式 → 对话格式"""
        
        # 构建用户消息
        user_content = alpaca_data['instruction']
        if alpaca_data.get('input'):
            user_content += f"\n\n输入：{alpaca_data['input']}"
        
        return {
            'messages': [
                {'role': 'user', 'content': user_content},
                {'role': 'assistant', 'content': alpaca_data['output']}
            ]
        }
    
    @staticmethod
    def chat_to_alpaca(chat_data: Dict) -> Dict:
        """对话格式 → Alpaca格式"""
        
        messages = chat_data['messages']
        
        # 简单转换：最后一对user-assistant
        user_msg = None
        assistant_msg = None
        
        for i, msg in enumerate(messages):
            if msg['role'] == 'user':
                user_msg = msg['content']
            elif msg['role'] == 'assistant' and user_msg:
                assistant_msg = msg['content']
                break
        
        return {
            'instruction': user_msg or '',
            'input': '',
            'output': assistant_msg or ''
        }

# 演示转换
converter = FormatConverter()

print("\n" + "="*60)
print("格式转换演示")
print("="*60)

# QA → Chat
qa = {"question": "什么是Python？", "answer": "Python是一种编程语言"}
chat = converter.qa_to_chat(qa)
print("\nQA → Chat:")
print(json.dumps(chat, ensure_ascii=False, indent=2))
```

---

## 💻 第二部分：数据清洗实战

### 一、完整的数据清洗流程

```python
import re
from typing import List, Set
import hashlib

class DataCleaner:
    """数据清洗器"""
    
    def __init__(self):
        # 停用词（示例）
        self.stop_words = {'的', '了', '在', '是'}
        
        # 已处理的数据指纹（用于去重）
        self.seen_fingerprints: Set[str] = set()
    
    def clean_dataset(self, dataset: List[Dict]) -> List[Dict]:
        """清洗整个数据集"""
        
        cleaned = []
        stats = {
            'original': len(dataset),
            'duplicates': 0,
            'too_short': 0,
            'too_long': 0,
            'invalid': 0,
            'cleaned': 0
        }
        
        for data in dataset:
            # 1. 格式验证
            if not self._validate_format(data):
                stats['invalid'] += 1
                continue
            
            # 2. 去重
            fingerprint = self._get_fingerprint(data)
            if fingerprint in self.seen_fingerprints:
                stats['duplicates'] += 1
                continue
            self.seen_fingerprints.add(fingerprint)
            
            # 3. 清洗内容
            cleaned_data = self._clean_single(data)
            
            # 4. 长度检查
            if self._is_too_short(cleaned_data):
                stats['too_short'] += 1
                continue
            
            if self._is_too_long(cleaned_data):
                stats['too_long'] += 1
                continue
            
            cleaned.append(cleaned_data)
            stats['cleaned'] += 1
        
        print(f"\n清洗统计：")
        print(f"  原始数据：{stats['original']}条")
        print(f"  重复数据：{stats['duplicates']}条")
        print(f"  过短数据：{stats['too_short']}条")
        print(f"  过长数据：{stats['too_long']}条")
        print(f"  无效数据：{stats['invalid']}条")
        print(f"  清洗后：{stats['cleaned']}条")
        
        return cleaned
    
    def _validate_format(self, data: Dict) -> bool:
        """验证数据格式"""
        
        # 检查必需字段
        if 'messages' in data:
            # 对话格式
            if not isinstance(data['messages'], list):
                return False
            if len(data['messages']) < 2:
                return False
            return True
        elif 'question' in data and 'answer' in data:
            # 问答格式
            return True
        elif 'instruction' in data and 'output' in data:
            # Alpaca格式
            return True
        
        return False
    
    def _get_fingerprint(self, data: Dict) -> str:
        """生成数据指纹（用于去重）"""
        
        # 提取主要内容
        content = ""
        if 'messages' in data:
            content = " ".join([msg['content'] for msg in data['messages']])
        elif 'question' in data:
            content = data['question'] + data['answer']
        elif 'instruction' in data:
            content = data['instruction'] + data['output']
        
        # 生成MD5哈希
        return hashlib.md5(content.encode()).hexdigest()
    
    def _clean_single(self, data: Dict) -> Dict:
        """清洗单条数据"""
        
        if 'messages' in data:
            # 清洗每条消息
            cleaned_messages = []
            for msg in data['messages']:
                cleaned_content = self._clean_text(msg['content'])
                cleaned_messages.append({
                    'role': msg['role'],
                    'content': cleaned_content
                })
            return {'messages': cleaned_messages}
        
        elif 'question' in data:
            return {
                'question': self._clean_text(data['question']),
                'answer': self._clean_text(data['answer'])
            }
        
        elif 'instruction' in data:
            return {
                'instruction': self._clean_text(data['instruction']),
                'input': self._clean_text(data.get('input', '')),
                'output': self._clean_text(data['output'])
            }
        
        return data
    
    def _clean_text(self, text: str) -> str:
        """清洗文本内容"""
        
        # 1. 去除多余空白
        text = re.sub(r'\s+', ' ', text)
        
        # 2. 去除HTML标签
        text = re.sub(r'<[^>]+>', '', text)
        
        # 3. 去除特殊字符（保留基本标点）
        text = re.sub(r'[^\w\s\u4e00-\u9fff.,!?;:，。！？；："""''（）()【】\[\]{}]', '', text)
        
        # 4. 统一标点
        replacements = {
            '，': ',',
            '。': '.',
            '！': '!',
            '？': '?',
            '；': ';',
            '：': ':',
        }
        for old, new in replacements.items():
            text = text.replace(old, new)
        
        # 5. 去除首尾空白
        text = text.strip()
        
        return text
    
    def _is_too_short(self, data: Dict, min_length: int = 10) -> bool:
        """检查是否过短"""
        
        content = self._extract_content(data)
        return len(content) < min_length
    
    def _is_too_long(self, data: Dict, max_length: int = 2000) -> bool:
        """检查是否过长"""
        
        content = self._extract_content(data)
        return len(content) > max_length
    
    def _extract_content(self, data: Dict) -> str:
        """提取内容用于长度检查"""
        
        if 'messages' in data:
            return " ".join([msg['content'] for msg in data['messages']])
        elif 'question' in data:
            return data['question'] + data['answer']
        elif 'instruction' in data:
            return data['instruction'] + data['output']
        
        return ""

# 演示
def demo_cleaning():
    """演示数据清洗"""
    
    # 测试数据
    raw_data = [
        {
            'messages': [
                {'role': 'user', 'content': '  Python是什么？  '},
                {'role': 'assistant', 'content': 'Python是<b>编程语言</b>'}
            ]
        },
        {
            'messages': [
                {'role': 'user', 'content': 'Python是什么？'},  # 重复
                {'role': 'assistant', 'content': 'Python是编程语言'}
            ]
        },
        {
            'question': '短',  # 过短
            'answer': '答'
        },
        {
            'question': 'A' * 1000,  # 过长
            'answer': 'B' * 1000
        },
    ]
    
    cleaner = DataCleaner()
    cleaned_data = cleaner.clean_dataset(raw_data)
    
    print(f"\n清洗后的数据：")
    for i, data in enumerate(cleaned_data, 1):
        print(f"\n{i}. {data}")

demo_cleaning()
```

---

## 🎯 第三部分：质量评估系统

### 一、自动质量评分

```python
class QualityScorer:
    """数据质量评分器"""
    
    def score_dataset(self, dataset: List[Dict]) -> Dict:
        """评估整个数据集"""
        
        scores = []
        
        for data in dataset:
            score = self.score_single(data)
            scores.append(score)
        
        avg_score = sum(scores) / len(scores) if scores else 0
        
        return {
            'total_samples': len(dataset),
            'average_score': avg_score,
            'excellent': sum(1 for s in scores if s >= 80),
            'good': sum(1 for s in scores if 60 <= s < 80),
            'poor': sum(1 for s in scores if s < 60),
            'scores': scores
        }
    
    def score_single(self, data: Dict) -> float:
        """评估单条数据（0-100分）"""
        
        scores = {}
        
        # 1. 完整性（25分）
        scores['completeness'] = self._score_completeness(data)
        
        # 2. 长度合理性（25分）
        scores['length'] = self._score_length(data)
        
        # 3. 文本质量（25分）
        scores['quality'] = self._score_quality(data)
        
        # 4. 格式正确性（25分）
        scores['format'] = self._score_format(data)
        
        total = sum(scores.values())
        
        return total
    
    def _score_completeness(self, data: Dict) -> float:
        """评估完整性"""
        
        score = 25.0
        
        # 检查必需字段
        if 'messages' in data:
            if len(data['messages']) < 2:
                score -= 15
            if any(not msg.get('content') for msg in data['messages']):
                score -= 10
        
        return max(0, score)
    
    def _score_length(self, data: Dict) -> float:
        """评估长度合理性"""
        
        content = self._extract_all_content(data)
        length = len(content)
        
        # 理想长度：50-500字符
        if 50 <= length <= 500:
            return 25.0
        elif length < 50:
            return 25.0 * (length / 50)
        else:
            # 过长扣分
            return max(0, 25.0 - (length - 500) / 100)
    
    def _score_quality(self, data: Dict) -> float:
        """评估文本质量"""
        
        content = self._extract_all_content(data)
        score = 25.0
        
        # 检查常见问题
        if re.search(r'[^\w\s\u4e00-\u9fff.,!?;:，。！？；："""''（）()【】\[\]]', content):
            score -= 5  # 有奇怪字符
        
        if len(re.findall(r'\.{3,}', content)) > 2:
            score -= 5  # 太多省略号
        
        if content.isupper():
            score -= 10  # 全大写
        
        return max(0, score)
    
    def _score_format(self, data: Dict) -> float:
        """评估格式正确性"""
        
        score = 25.0
        
        # 检查格式
        has_messages = 'messages' in data
        has_qa = 'question' in data and 'answer' in data
        has_alpaca = 'instruction' in data and 'output' in data
        
        if not (has_messages or has_qa or has_alpaca):
            return 0
        
        return score
    
    def _extract_all_content(self, data: Dict) -> str:
        """提取所有文本内容"""
        
        if 'messages' in data:
            return " ".join([msg.get('content', '') for msg in data['messages']])
        elif 'question' in data:
            return data.get('question', '') + data.get('answer', '')
        elif 'instruction' in data:
            return data.get('instruction', '') + data.get('output', '')
        
        return ""

# 演示
scorer = QualityScorer()

test_data = [
    {
        'messages': [
            {'role': 'user', 'content': 'Python是什么？'},
            {'role': 'assistant', 'content': 'Python是一种高级编程语言，以简洁和可读性著称。'}
        ]
    },
    {
        'question': '短',
        'answer': '很短的回答'
    },
]

result = scorer.score_dataset(test_data)
print("\n质量评估结果：")
print(f"  平均分：{result['average_score']:.1f}")
print(f"  优秀：{result['excellent']}条")
print(f"  良好：{result['good']}条")
print(f"  较差：{result['poor']}条")
```

---

## 📝 课后练习

### 练习1：数据清洗
清洗一个真实数据集

### 练习2：格式转换
实现自己的格式转换器

### 练习3：质量评估
为你的数据集评分

---

## 🎓 知识总结

### 核心要点

1. **数据格式**
   - 3种标准格式
   - 格式转换
   - 验证工具

2. **数据清洗**
   - 去重
   - 格式统一
   - 错误修正
   - 噪声过滤

3. **质量评估**
   - 完整性
   - 长度
   - 文本质量
   - 格式正确性

4. **最佳实践**
   - 质量>数量
   - 严格验证
   - 持续优化

---

## 🚀 下节预告

下一课：**第93课：LoRA原理与实现详解**

- LoRA数学原理
- 参数高效微调
- 代码实现
- 实战案例

**开始真正的微调！** 🔥

---

**💪 记住：好数据是成功微调的一半！**

**下一课见！** 🎉
