![知识图谱架构](./images/knowledge_graph.svg)
*图：知识图谱架构*

# 第70.1课：知识图谱基础与Neo4j入门

> **本课目标**：理解知识图谱原理，掌握Neo4j图数据库基础操作
> 
> **核心技能**：知识图谱概念、Neo4j安装配置、Cypher查询语言、图数据建模
> 
> **学习时长**：90分钟
> 
> **重要性**：⭐⭐⭐⭐⭐（AI工程师必备技能，工业界明确要求）

---

## 📖 口播文案（7分钟）

### 🎯 前言

"**恭喜你来到知识图谱章节！**

前面我们学习了：
- 向量数据库：语义检索
- RAG系统：文档问答

但你可能遇到过这些问题：

**问题1：向量检索无法理解关系**

```
场景：企业组织架构查询

用户问："张三的直属领导的部门经理是谁？"

传统向量RAG：
• 检索到张三的信息 ✅
• 检索到领导的信息 ✅
• 但无法推理多跳关系 ❌

结果：答不出来或答错

知识图谱：
• 张三 -[直属]-> 李四（领导）
• 李四 -[属于]-> 技术部
• 技术部 -[经理]-> 王五

答案：王五 ✅ 

准确！清晰！可追溯！
```

**问题2：向量检索难以处理结构化知识**

```
场景：医疗诊断

用户问："高血压患者禁用哪些药物？"

传统向量RAG：
检索文档："高血压患者应注意用药..."
• 信息分散
• 容易遗漏
• 无法保证完整性

知识图谱：
高血压 -[禁用]-> 药物A
高血压 -[禁用]-> 药物B
高血压 -[禁用]-> 药物C
...

一次查询，完整列出所有禁用药物！
```

**今天，我要告诉你：知识图谱的强大之处！**

---

### 💡 什么是知识图谱？

**直觉理解：**

```
【向量数据库】= 图书馆的书架
• 按主题分类
• 语义相似的放一起
• 找相关内容很快

但：
• 不知道书与书之间的关系
• 不知道作者与作者的关系
• 不知道概念与概念的关系

【知识图谱】= 知识的关系网络
• 不仅有知识点
• 还有知识点之间的关系
• 可以推理、可以追溯

就像：
• 人脉关系网
• 公司组织架构图
• 地铁线路图
```

**技术定义：**

知识图谱（Knowledge Graph）是一种**结构化的语义知识库**：

```
核心组成：
1. 实体（Entity）：现实世界的对象
   • 人：张三、李四
   • 地点：北京、上海
   • 概念：人工智能、深度学习

2. 关系（Relation）：实体之间的联系
   • 工作于、毕业于、父亲、朋友
   • 属于、包含、相关
   • 因果、时序

3. 属性（Property）：实体的特征
   • 张三.年龄 = 30
   • 张三.职位 = "AI工程师"
   • 张三.技能 = ["Python", "LangChain"]
```

**知识图谱 vs 向量数据库：**

```
【场景1：简单查询】

问题："人工智能是什么？"

向量数据库：✅ 完美
• 语义检索
• 找到相关文档
• 生成答案

知识图谱：⚠️ 过度
• 可以做，但没必要

【场景2：关系查询】

问题："张三认识的人中，有谁在北京工作？"

向量数据库：❌ 难处理
• 检索到张三的朋友
• 检索到北京的人
• 但无法精确匹配关系

知识图谱：✅ 完美
• 张三 -[认识]-> 李四
• 李四 -[工作于]-> 北京
• 一次查询，精确结果

【场景3：多跳推理】

问题："张三朋友的朋友中，有AI工程师吗？"

向量数据库：❌ 几乎不可能
• 无法处理多层关系

知识图谱：✅ 完美
• 2跳查询
• 精确推理
```

**什么时候用知识图谱？**

```
✅ 适合知识图谱：
1. 关系复杂的场景
   • 企业组织架构
   • 供应链网络
   • 金融风控（关联公司）
   • 社交网络分析

2. 需要精确推理的场景
   • 医疗诊断（症状-疾病-药物）
   • 法律咨询（法条-案例-判决）
   • 技术选型（技术-依赖-版本）

3. 需要结构化知识的场景
   • 产品知识库（产品-功能-文档）
   • 学科知识体系（概念-关系-层级）

⚠️ 不适合知识图谱：
1. 纯文本检索
   • 简单问答
   • 文档搜索
   → 用向量数据库更简单

2. 非结构化知识
   • 创意写作
   • 开放讨论
   → 用RAG更合适

💡 最佳实践：
知识图谱 + 向量数据库 = Graph RAG
• 结构化知识用图谱
• 非结构化文本用向量
• 两者结合，威力巨大！
```

---

## 📚 核心知识

### 一、知识图谱三要素

#### 1. 实体（Entity）

```
定义：现实世界中的对象

类型：
• 人物：张三、李四、马斯克
• 组织：苹果公司、清华大学
• 地点：北京、硅谷
• 概念：人工智能、机器学习
• 事件：iPhone发布、GPT-4发布
• 时间：2024年、11月23日

表示：
• 每个实体有唯一ID
• 有类型标签（Label）
• 有属性（Properties）

示例：
实体：张三
类型：Person
属性：
  - name: "张三"
  - age: 30
  - job: "AI工程师"
  - skills: ["Python", "LangChain", "RAG"]
```

#### 2. 关系（Relation）

```
定义：实体之间的联系

类型：
• 社交关系：朋友、同事、师生
• 层级关系：属于、包含、管理
• 语义关系：相似、相反、等价
• 因果关系：导致、影响
• 时序关系：之前、之后

特点：
• 有方向性：A -[朋友]-> B
• 有类型：朋友、同事
• 可以有属性：认识时间、关系强度

示例：
关系：张三 -[工作于]-> 字节跳动
类型：WORKS_AT
属性：
  - start_date: "2020-01-01"
  - position: "AI工程师"
  - department: "AI Lab"
```

#### 3. 属性（Property）

```
定义：实体或关系的特征

实体属性示例：
Person {
  name: "张三",
  age: 30,
  email: "zhangsan@example.com",
  skills: ["Python", "AI"],
  experience: 5
}

关系属性示例：
张三 -[朋友 {
  since: "2015-06-01",
  closeness: 0.8,
  contact_frequency: "weekly"
}]-> 李四
```

---

### 二、图数据库基础

#### 1. 什么是图数据库？

```
传统关系型数据库（MySQL）：
• 表格结构
• SQL查询
• 不擅长处理关系

图数据库（Neo4j）：
• 图结构
• Cypher查询
• 专为关系设计

性能对比：

场景：查询"张三3度朋友"

MySQL：
• 需要3次JOIN
• 性能随层数指数下降
• 10万用户，3度查询：10秒+

Neo4j：
• 直接遍历图
• 性能几乎不随层数增长
• 10万用户，3度查询：<100ms

差距：100倍！
```

#### 2. Neo4j是什么？

```
Neo4j：
• 全球最流行的图数据库
• 原生图存储
• ACID事务支持
• 强大的Cypher查询语言
• 可视化界面
• 开源 + 企业版

为什么选Neo4j？
✅ 性能最强
✅ 社区最大
✅ 工具最全
✅ 文档最好
✅ 工业界标准
```

---

### 三、Neo4j安装与配置

#### 方式1：Docker安装（推荐）

```bash
# 1. 拉取Neo4j镜像
docker pull neo4j:latest

# 2. 启动Neo4j容器
docker run -d \
  --name neo4j \
  -p 7474:7474 \
  -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/your_password \
  -v $HOME/neo4j/data:/data \
  -v $HOME/neo4j/logs:/logs \
  neo4j:latest

# 3. 访问Web界面
# 浏览器打开：http://localhost:7474
# 用户名：neo4j
# 密码：your_password
```

#### 方式2：本地安装

```bash
# macOS（使用Homebrew）
brew install neo4j
neo4j start

# Linux
wget -O - https://debian.neo4j.com/neotechnology.gpg.key | sudo apt-key add -
echo 'deb https://debian.neo4j.com stable latest' | sudo tee /etc/apt/sources.list.d/neo4j.list
sudo apt-get update
sudo apt-get install neo4j

# Windows
# 下载：https://neo4j.com/download/
# 安装后启动Neo4j Desktop
```

#### 方式3：Neo4j Aura（云服务）

```
1. 访问：https://neo4j.com/cloud/aura/
2. 注册账号
3. 创建免费实例
4. 获取连接凭证

优点：
• 无需安装
• 自动备份
• 高可用

缺点：
• 免费版有限制
• 需要网络连接
```

---

### 四、Cypher查询语言基础

Cypher是Neo4j的查询语言，类似SQL但专为图设计。

#### 1. 创建节点

```cypher
// 创建一个人物节点
CREATE (p:Person {
  name: "张三",
  age: 30,
  job: "AI工程师"
})

// 创建多个节点
CREATE (p1:Person {name: "张三", age: 30})
CREATE (p2:Person {name: "李四", age: 28})
CREATE (c:Company {name: "字节跳动", location: "北京"})
```

#### 2. 创建关系

```cypher
// 创建带关系的节点
CREATE (p1:Person {name: "张三"})
CREATE (p2:Person {name: "李四"})
CREATE (p1)-[:FRIEND {since: "2020-01-01"}]->(p2)

// 或者一次性创建
CREATE (p1:Person {name: "张三"})
      -[:WORKS_AT {since: "2020-01-01"}]->
      (c:Company {name: "字节跳动"})
```

#### 3. 查询节点

```cypher
// 查询所有Person节点
MATCH (p:Person)
RETURN p

// 按条件查询
MATCH (p:Person)
WHERE p.name = "张三"
RETURN p

// 简写
MATCH (p:Person {name: "张三"})
RETURN p
```

#### 4. 查询关系

```cypher
// 查询张三的朋友
MATCH (p:Person {name: "张三"})-[:FRIEND]->(friend)
RETURN friend

// 查询张三工作的公司
MATCH (p:Person {name: "张三"})-[:WORKS_AT]->(c:Company)
RETURN c

// 查询任意关系
MATCH (p:Person {name: "张三"})-[r]->(other)
RETURN type(r), other
```

#### 5. 更新数据

```cypher
// 更新属性
MATCH (p:Person {name: "张三"})
SET p.age = 31
RETURN p

// 添加属性
MATCH (p:Person {name: "张三"})
SET p.email = "zhangsan@example.com"
RETURN p

// 删除属性
MATCH (p:Person {name: "张三"})
REMOVE p.email
RETURN p
```

#### 6. 删除数据

```cypher
// 删除节点（需先删除关系）
MATCH (p:Person {name: "张三"})
DETACH DELETE p

// 只删除关系
MATCH (p1:Person {name: "张三"})-[r:FRIEND]->(p2)
DELETE r

// 删除所有数据（慎用！）
MATCH (n)
DETACH DELETE n
```

---


![Cypher](./images/cypher.svg)
*图：Cypher*

## 💻 实战练习

### 练习1：构建简单的社交网络

**目标**：创建一个包含5个人和他们关系的社交网络

```cypher
// 1. 创建人物节点
CREATE (zhang:Person {name: "张三", age: 30, job: "AI工程师"})
CREATE (li:Person {name: "李四", age: 28, job: "后端工程师"})
CREATE (wang:Person {name: "王五", age: 32, job: "产品经理"})
CREATE (zhao:Person {name: "赵六", age: 29, job: "前端工程师"})
CREATE (qian:Person {name: "钱七", age: 31, job: "数据科学家"})

// 2. 创建朋友关系
MATCH (zhang:Person {name: "张三"}), (li:Person {name: "李四"})
CREATE (zhang)-[:FRIEND {since: "2020-01-01"}]->(li)

MATCH (zhang:Person {name: "张三"}), (wang:Person {name: "王五"})
CREATE (zhang)-[:FRIEND {since: "2019-06-15"}]->(wang)

MATCH (li:Person {name: "李四"}), (zhao:Person {name: "赵六"})
CREATE (li)-[:FRIEND {since: "2021-03-20"}]->(zhao)

MATCH (wang:Person {name: "王五"}), (qian:Person {name: "钱七"})
CREATE (wang)-[:FRIEND {since: "2018-09-10"}]->(qian)

// 3. 创建同事关系
CREATE (c:Company {name: "字节跳动", location: "北京"})

MATCH (zhang:Person {name: "张三"}), (c:Company {name: "字节跳动"})
CREATE (zhang)-[:WORKS_AT {since: "2020-01-01", department: "AI Lab"}]->(c)

MATCH (li:Person {name: "李四"}), (c:Company {name: "字节跳动"})
CREATE (li)-[:WORKS_AT {since: "2020-06-01", department: "Backend"}]->(c)

MATCH (zhao:Person {name: "赵六"}), (c:Company {name: "字节跳动"})
CREATE (zhao)-[:WORKS_AT {since: "2021-01-01", department: "Frontend"}]->(c)
```

### 练习2：查询练习

```cypher
// 1. 查询所有人
MATCH (p:Person)
RETURN p.name, p.age, p.job

// 2. 查询张三的所有朋友
MATCH (zhang:Person {name: "张三"})-[:FRIEND]->(friend)
RETURN friend.name, friend.job

// 3. 查询在字节跳动工作的所有人
MATCH (p:Person)-[:WORKS_AT]->(c:Company {name: "字节跳动"})
RETURN p.name, p.job

// 4. 查询张三朋友的朋友（2度好友）
MATCH (zhang:Person {name: "张三"})-[:FRIEND*2]->(friend_of_friend)
WHERE friend_of_friend.name <> "张三"
RETURN DISTINCT friend_of_friend.name

// 5. 查询最早认识的朋友
MATCH (p:Person {name: "张三"})-[r:FRIEND]->(friend)
RETURN friend.name, r.since
ORDER BY r.since
LIMIT 1

// 6. 统计每个公司有多少员工
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN c.name, COUNT(p) as employee_count
```

### 练习3：复杂查询

```cypher
// 1. 推荐朋友：找到朋友的朋友但不是自己的朋友
MATCH (me:Person {name: "张三"})-[:FRIEND]->()-[:FRIEND]->(fof)
WHERE NOT (me)-[:FRIEND]->(fof) AND fof <> me
RETURN DISTINCT fof.name, fof.job

// 2. 查询共同朋友
MATCH (p1:Person {name: "张三"})-[:FRIEND]->(common)<-[:FRIEND]-(p2:Person {name: "李四"})
RETURN common.name

// 3. 查询最短路径
MATCH path = shortestPath(
  (p1:Person {name: "张三"})-[:FRIEND*]-(p2:Person {name: "钱七"})
)
RETURN path, length(path)

// 4. 查询部门同事
MATCH (me:Person {name: "张三"})-[r1:WORKS_AT]->(c:Company)
MATCH (colleague:Person)-[r2:WORKS_AT]->(c)
WHERE r1.department = r2.department AND colleague <> me
RETURN colleague.name, r2.department
```

---

## 🎯 Python连接Neo4j

### 安装依赖

```bash
pip install neo4j
```

### 基础连接

```python
from neo4j import GraphDatabase

class Neo4jConnection:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def close(self):
        self.driver.close()
    
    def query(self, cypher_query, parameters=None):
        """执行Cypher查询"""
        with self.driver.session() as session:
            result = session.run(cypher_query, parameters)
            return [record for record in result]

# 使用示例
conn = Neo4jConnection(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="your_password"
)

# 执行查询
result = conn.query("MATCH (p:Person) RETURN p.name AS name")
for record in result:
    print(record["name"])

conn.close()
```

### 完整示例：构建知识图谱

```python
from neo4j import GraphDatabase

class KnowledgeGraph:
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
    
    def close(self):
        self.driver.close()
    
    def create_person(self, name, age, job):
        """创建人物节点"""
        with self.driver.session() as session:
            result = session.run(
                """
                CREATE (p:Person {name: $name, age: $age, job: $job})
                RETURN p
                """,
                name=name, age=age, job=job
            )
            return result.single()
    
    def create_friendship(self, person1, person2, since):
        """创建朋友关系"""
        with self.driver.session() as session:
            result = session.run(
                """
                MATCH (p1:Person {name: $person1})
                MATCH (p2:Person {name: $person2})
                CREATE (p1)-[r:FRIEND {since: $since}]->(p2)
                RETURN r
                """,
                person1=person1, person2=person2, since=since
            )
            return result.single()
    
    def get_friends(self, person_name):
        """查询某人的朋友"""
        with self.driver.session() as session:
            result = session.run(
                """
                MATCH (p:Person {name: $name})-[:FRIEND]->(friend)
                RETURN friend.name AS name, friend.job AS job
                """,
                name=person_name
            )
            return [{"name": record["name"], "job": record["job"]} 
                    for record in result]
    
    def get_friend_of_friends(self, person_name):
        """查询朋友的朋友"""
        with self.driver.session() as session:
            result = session.run(
                """
                MATCH (p:Person {name: $name})-[:FRIEND*2]->(fof)
                WHERE fof.name <> $name
                RETURN DISTINCT fof.name AS name, fof.job AS job
                """,
                name=person_name
            )
            return [{"name": record["name"], "job": record["job"]} 
                    for record in result]

# 使用示例
kg = KnowledgeGraph(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="your_password"
)

# 创建节点
kg.create_person("张三", 30, "AI工程师")
kg.create_person("李四", 28, "后端工程师")

# 创建关系
kg.create_friendship("张三", "李四", "2020-01-01")

# 查询
friends = kg.get_friends("张三")
print("张三的朋友：", friends)

fof = kg.get_friend_of_friends("张三")
print("朋友的朋友：", fof)

kg.close()
```

---

## 🎯 本课小结

### 核心要点

1. **知识图谱 = 结构化的关系网络**
   - 实体 + 关系 + 属性
   - 擅长处理复杂关系
   - 支持多跳推理

2. **知识图谱 vs 向量数据库**
   - 简单检索 → 向量数据库
   - 关系查询 → 知识图谱
   - 最佳实践 → Graph RAG（结合两者）

3. **Neo4j是图数据库之王**
   - 性能强大
   - Cypher查询语言简洁
   - 工具完善

4. **Cypher基础语法**
   ```cypher
   CREATE   # 创建
   MATCH    # 查询
   WHERE    # 条件
   RETURN   # 返回
   SET      # 更新
   DELETE   # 删除
   ```

### 下节预告

**第70.2课：知识图谱构建-实体关系抽取**
- 从文本中自动抽取实体
- 识别实体之间的关系
- 使用NER和关系抽取技术
- 批量构建知识图谱

---

## 📝 课后作业

### 作业1：构建技术栈知识图谱

创建一个AI技术栈的知识图谱：

```
实体：
- 技术：Python, LangChain, RAG, Agent, Neo4j
- 领域：AI应用开发, 后端开发, 数据科学
- 公司：OpenAI, Anthropic, 字节跳动

关系：
- 依赖：LangChain -[DEPENDS_ON]-> Python
- 应用于：RAG -[USED_IN]-> AI应用开发
- 开发者：OpenAI -[DEVELOPS]-> ChatGPT

要求：
1. 至少10个实体
2. 至少10个关系
3. 包含属性信息
```

### 作业2：查询练习

基于你创建的技术栈图谱，完成以下查询：

1. 查询所有技术及其依赖
2. 查询某个技术可以应用的领域
3. 查询OpenAI开发的所有产品
4. 推荐相关技术（共享依赖的技术）

---

**准备好深入知识图谱的世界了吗？下一课见！** 🚀

