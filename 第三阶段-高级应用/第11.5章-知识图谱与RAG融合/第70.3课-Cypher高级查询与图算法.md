![çŸ¥è¯†å›¾è°±æ¶æ„](./images/knowledge_graph.svg)
*å›¾ï¼šçŸ¥è¯†å›¾è°±æ¶æ„*

# ç¬¬70.3è¯¾ï¼šCypheré«˜çº§æŸ¥è¯¢ä¸å›¾ç®—æ³•

> **æœ¬è¯¾ç›®æ ‡**ï¼šæŒæ¡Cypheré«˜çº§æŸ¥è¯¢æŠ€å·§å’Œå›¾ç®—æ³•åº”ç”¨
> 
> **æ ¸å¿ƒæŠ€èƒ½**ï¼šå¤æ‚æŸ¥è¯¢ã€è·¯å¾„æŸ¥æ‰¾ã€ç¤¾åŒºå‘ç°ã€ä¸­å¿ƒæ€§åˆ†æã€æ¨èç®—æ³•
> 
> **å­¦ä¹ æ—¶é•¿**ï¼š95åˆ†é’Ÿ
> 
> **é‡è¦æ€§**ï¼šâ­â­â­â­â­ï¼ˆçŸ¥è¯†å›¾è°±æ·±åº¦åº”ç”¨ï¼Œé«˜çº§æŠ€èƒ½ï¼‰

---

## ğŸ“– å£æ’­æ–‡æ¡ˆï¼ˆ7åˆ†é’Ÿï¼‰

### ğŸ¯ å‰è¨€

"**æ¬¢è¿æ¥åˆ°Cypheré«˜çº§æŸ¥è¯¢è¯¾ç¨‹ï¼**

å‰é¢æˆ‘ä»¬å­¦ä¹ äº†Neo4jåŸºç¡€å’Œå®ä½“å…³ç³»æŠ½å–ï¼Œä»Šå¤©è¦å­¦ä¹ ï¼š**å¦‚ä½•æ·±åº¦æŒ–æ˜çŸ¥è¯†å›¾è°±çš„ä»·å€¼**

**æ ¸å¿ƒé—®é¢˜ï¼šçŸ¥è¯†å›¾è°±æ„å»ºå¥½äº†ï¼Œå¦‚ä½•é«˜æ•ˆæŸ¥è¯¢å’Œåˆ†æï¼Ÿ**

```
åœºæ™¯1ï¼šå¤æ‚å…³ç³»æŸ¥è¯¢

é—®é¢˜ï¼š"å¼ ä¸‰çš„æœ‹å‹çš„æœ‹å‹ä¸­ï¼Œæœ‰è°åœ¨AIé¢†åŸŸå·¥ä½œï¼Ÿ"

ç®€å•æŸ¥è¯¢ï¼š
MATCH (p:Person {name: "å¼ ä¸‰"})-[:FRIEND]->()-[:FRIEND]->(fof)
RETURN fof

ä½†å¦‚æœè¦åŠ ä¸Šæ›´å¤šæ¡ä»¶å‘¢ï¼Ÿ
â€¢ æ’é™¤å·²ç»è®¤è¯†çš„äºº
â€¢ åªè¦åœ¨AIé¢†åŸŸçš„
â€¢ æŒ‰å…±åŒæœ‹å‹æ•°æ’åº
â€¢ é™åˆ¶è·³æ•°

éœ€è¦é«˜çº§æŸ¥è¯¢æŠ€å·§ï¼

åœºæ™¯2ï¼šæœ€çŸ­è·¯å¾„

é—®é¢˜ï¼š"å¼ ä¸‰å’Œæå››ä¹‹é—´çš„æœ€çŸ­å…³ç³»è·¯å¾„æ˜¯ä»€ä¹ˆï¼Ÿ"

ç®€å•åšæ³•ï¼š
â€¢ éå†æ‰€æœ‰è·¯å¾„ï¼Ÿå¤ªæ…¢ï¼
â€¢ éœ€è¦ä¸“é—¨çš„è·¯å¾„ç®—æ³•

åœºæ™¯3ï¼šç¤¾åŒºå‘ç°

é—®é¢˜ï¼š"æŠ€æœ¯äººå‘˜ä¸­æœ‰å“ªäº›å°åœˆå­ï¼Ÿ"

éœ€è¦ï¼š
â€¢ ç¤¾åŒºæ£€æµ‹ç®—æ³•
â€¢ èšç±»åˆ†æ
â€¢ å›¾ç®—æ³•

åœºæ™¯4ï¼šæ¨èç³»ç»Ÿ

é—®é¢˜ï¼š"ç»™å¼ ä¸‰æ¨èå¯èƒ½è®¤è¯†çš„äºº"

éœ€è¦ï¼š
â€¢ ååŒè¿‡æ»¤
â€¢ å›¾ç›¸ä¼¼åº¦
â€¢ PageRank

è¿™äº›éƒ½éœ€è¦é«˜çº§æŠ€æœ¯ï¼
```

**ä»Šå¤©è¦å­¦ä¹ ï¼šCypheré«˜çº§æŸ¥è¯¢ + Neo4jå›¾ç®—æ³•ï¼**

---

## ğŸ“š Cypheré«˜çº§æŸ¥è¯¢

### ä¸€ã€å¤æ‚æ¨¡å¼åŒ¹é…

#
![CypheræŸ¥è¯¢](./images/cypher.svg)
*å›¾ï¼šCypheræŸ¥è¯¢*

### 1. å¯å˜é•¿è·¯å¾„

```cypher
// 1-3è·³æœ‹å‹
MATCH (p:Person {name: "å¼ ä¸‰"})-[:FRIEND*1..3]->(friend)
RETURN DISTINCT friend.name

// 2è·³ä»¥ä¸Šçš„æœ‹å‹ï¼ˆæ’é™¤1è·³ï¼‰
MATCH (p:Person {name: "å¼ ä¸‰"})-[:FRIEND*2..]->(friend)
WHERE NOT (p)-[:FRIEND]->(friend)  // æ’é™¤ç›´æ¥æœ‹å‹
RETURN DISTINCT friend.name

// ä»»æ„è·³æ•°æœ‹å‹
MATCH (p:Person {name: "å¼ ä¸‰"})-[:FRIEND*]->(friend)
RETURN friend.name, length(path) as distance
ORDER BY distance
LIMIT 10
```

#### 2. å¤šæ¡ä»¶è¿‡æ»¤

```cypher
// æœ‹å‹çš„æœ‹å‹ï¼Œåœ¨AIé¢†åŸŸï¼Œå¹´é¾„ç›¸è¿‘
MATCH (me:Person {name: "å¼ ä¸‰"})-[:FRIEND]->()-[:FRIEND]->(fof:Person)
WHERE fof.age > me.age - 5 
  AND fof.age < me.age + 5
  AND "AI" IN fof.skills
  AND NOT (me)-[:FRIEND]->(fof)  // æ’é™¤å·²è®¤è¯†çš„
RETURN fof.name, fof.age, fof.skills
ORDER BY fof.age
LIMIT 10
```

#### 3. è·¯å¾„å˜é‡

```cypher
// ä¿å­˜è·¯å¾„ï¼Œåˆ†æè·¯å¾„ä¿¡æ¯
MATCH path = (p1:Person)-[:FRIEND*1..3]-(p2:Person)
WHERE p1.name = "å¼ ä¸‰" AND p2.name = "æå››"
RETURN 
    path,
    length(path) as path_length,
    [node in nodes(path) | node.name] as people,
    [rel in relationships(path) | type(rel)] as relations
ORDER BY path_length
LIMIT 1
```

#### 4. æœ€çŸ­è·¯å¾„

```cypher
// æœ€çŸ­è·¯å¾„
MATCH path = shortestPath(
    (p1:Person {name: "å¼ ä¸‰"})-[*]-(p2:Person {name: "æå››"})
)
RETURN path, length(path)

// æ‰€æœ‰æœ€çŸ­è·¯å¾„ï¼ˆå¯èƒ½æœ‰å¤šæ¡ï¼‰
MATCH path = allShortestPaths(
    (p1:Person {name: "å¼ ä¸‰"})-[*]-(p2:Person {name: "æå››"})
)
RETURN path, length(path)
```

---

### äºŒã€èšåˆä¸ç»Ÿè®¡

#### 1. åŸºç¡€èšåˆ

```cypher
// ç»Ÿè®¡æ¯ä¸ªå…¬å¸çš„å‘˜å·¥æ•°
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
RETURN c.name as company, COUNT(p) as employee_count
ORDER BY employee_count DESC

// è®¡ç®—å¹³å‡å¹´é¾„
MATCH (p:Person)
RETURN AVG(p.age) as avg_age,
       MIN(p.age) as min_age,
       MAX(p.age) as max_age,
       STDEV(p.age) as std_age

// æ”¶é›†æ‰€æœ‰æŠ€èƒ½
MATCH (p:Person)
RETURN COLLECT(DISTINCT p.skills) as all_skills
```

#### 2. åˆ†ç»„ç»Ÿè®¡

```cypher
// æŒ‰å…¬å¸ç»Ÿè®¡æŠ€èƒ½åˆ†å¸ƒ
MATCH (p:Person)-[:WORKS_AT]->(c:Company)
UNWIND p.skills as skill
RETURN 
    c.name as company,
    skill,
    COUNT(*) as skill_count
ORDER BY company, skill_count DESC

// æŒ‰å¹´é¾„æ®µåˆ†ç»„
MATCH (p:Person)
WITH p, (p.age / 10) * 10 as age_group
RETURN 
    age_group,
    COUNT(p) as count,
    AVG(p.age) as avg_age
ORDER BY age_group
```

#### 3. å­æŸ¥è¯¢ï¼ˆSubqueryï¼‰

```cypher
// æŸ¥æ‰¾æ¯ä¸ªäººçš„å‰3ä¸ªæœ€äº²å¯†çš„æœ‹å‹
MATCH (p:Person)
CALL {
    WITH p
    MATCH (p)-[r:FRIEND]->(friend)
    RETURN friend
    ORDER BY r.closeness DESC
    LIMIT 3
}
RETURN p.name, COLLECT(friend.name) as top_friends
```

---

### ä¸‰ã€æ¡ä»¶é€»è¾‘

#### 1. CASEè¡¨è¾¾å¼

```cypher
// æ ¹æ®å¹´é¾„åˆ†çº§
MATCH (p:Person)
RETURN 
    p.name,
    p.age,
    CASE
        WHEN p.age < 25 THEN "å¹´è½»"
        WHEN p.age < 35 THEN "ä¸­å¹´"
        WHEN p.age < 50 THEN "ä¸­è€å¹´"
        ELSE "è€å¹´"
    END as age_group

// æŠ€èƒ½ç­‰çº§è¯„ä¼°
MATCH (p:Person)
RETURN 
    p.name,
    CASE
        WHEN SIZE(p.skills) > 10 THEN "ä¸“å®¶"
        WHEN SIZE(p.skills) > 5 THEN "ç†Ÿç»ƒ"
        WHEN SIZE(p.skills) > 2 THEN "å…¥é—¨"
        ELSE "æ–°æ‰‹"
    END as skill_level
```

#### 2. OPTIONAL MATCH

```cypher
// æŸ¥è¯¢æ‰€æœ‰äººåŠå…¶å…¬å¸ï¼ˆå¯èƒ½æ²¡æœ‰ï¼‰
MATCH (p:Person)
OPTIONAL MATCH (p)-[:WORKS_AT]->(c:Company)
RETURN p.name, COALESCE(c.name, "æ— ") as company

// æŸ¥æ‰¾æœ‹å‹åŠå…¶å…±åŒæœ‹å‹æ•°
MATCH (me:Person {name: "å¼ ä¸‰"})-[:FRIEND]->(friend)
OPTIONAL MATCH (me)-[:FRIEND]->()<-[:FRIEND]-(friend)
RETURN 
    friend.name,
    COUNT(DISTINCT friend) as mutual_friends
ORDER BY mutual_friends DESC
```

---

### å››ã€é«˜çº§æŸ¥è¯¢æŠ€å·§

#### 1. æ¨èæœ‹å‹ï¼ˆååŒè¿‡æ»¤ï¼‰

```cypher
// åŸºäºå…±åŒæœ‹å‹æ¨è
MATCH (me:Person {name: "å¼ ä¸‰"})-[:FRIEND]->(friend)-[:FRIEND]->(fof)
WHERE NOT (me)-[:FRIEND]->(fof)  // ä¸æ˜¯å·²æœ‰æœ‹å‹
  AND me <> fof  // ä¸æ˜¯è‡ªå·±
WITH fof, COUNT(DISTINCT friend) as mutual_friends
WHERE mutual_friends >= 2  // è‡³å°‘2ä¸ªå…±åŒæœ‹å‹
RETURN 
    fof.name,
    fof.age,
    fof.company,
    mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10

// åŸºäºå…´è¶£æ¨è
MATCH (me:Person {name: "å¼ ä¸‰"})-[:FRIEND]->(friend)
WITH me, COLLECT(DISTINCT friend.skills) as friend_skills
UNWIND friend_skills as skills
MATCH (candidate:Person)
WHERE candidate <> me
  AND NOT (me)-[:FRIEND]->(candidate)
  AND ANY(skill IN candidate.skills WHERE skill IN skills)
WITH candidate, COUNT(*) as skill_overlap
RETURN 
    candidate.name,
    skill_overlap,
    candidate.skills
ORDER BY skill_overlap DESC
LIMIT 10
```

#### 2. å½±å“åŠ›åˆ†æ

```cypher
// è®¡ç®—æ¯ä¸ªäººçš„å½±å“åŠ›ï¼ˆæœ‹å‹æ•°ï¼‰
MATCH (p:Person)
OPTIONAL MATCH (p)-[:FRIEND]-(friend)
RETURN 
    p.name,
    COUNT(DISTINCT friend) as influence_score
ORDER BY influence_score DESC
LIMIT 10

// äºŒåº¦å½±å“åŠ›ï¼ˆæœ‹å‹çš„æœ‹å‹æ•°ï¼‰
MATCH (p:Person)-[:FRIEND]->()-[:FRIEND]->(fof)
WITH p, COUNT(DISTINCT fof) as second_degree_reach
RETURN 
    p.name,
    second_degree_reach
ORDER BY second_degree_reach DESC
LIMIT 10
```

#### 3. è·¯å¾„åˆ†æ

```cypher
// æŸ¥æ‰¾å…³é”®èŠ‚ç‚¹ï¼ˆè·¯å¾„å¿…ç»ä¹‹åœ°ï¼‰
MATCH path = (p1:Person)-[:FRIEND*]-(p2:Person)
WHERE p1.name = "å¼ ä¸‰" AND p2.name = "æå››"
WITH nodes(path) as path_nodes
UNWIND path_nodes as node
RETURN 
    node.name,
    COUNT(*) as appearance_count
ORDER BY appearance_count DESC

// æŸ¥æ‰¾æœ€å¤šå‡ºç°åœ¨è·¯å¾„ä¸­çš„äººï¼ˆæ¡¥æ¢èŠ‚ç‚¹ï¼‰
MATCH (p1:Person)-[:FRIEND*2..4]-(p2:Person)
WHERE p1 <> p2
WITH p1, p2, [node in nodes(path) | node.name][1..-1] as middle_nodes
UNWIND middle_nodes as bridge
RETURN 
    bridge,
    COUNT(*) as bridge_count
ORDER BY bridge_count DESC
LIMIT 10
```

---

## ğŸ¯ Neo4jå›¾ç®—æ³•åº“ï¼ˆGDSï¼‰

### ä¸€ã€å®‰è£…ä¸é…ç½®

```bash
# 1. ä¸‹è½½GDSæ’ä»¶
# https://neo4j.com/download-center/#algorithms

# 2. æ”¾åˆ°Neo4jçš„pluginsç›®å½•
# neo4j/plugins/neo4j-graph-data-science-*.jar

# 3. ä¿®æ”¹neo4j.conf
# dbms.security.procedures.unrestricted=gds.*
# dbms.security.procedures.allowlist=gds.*

# 4. é‡å¯Neo4j

# 5. éªŒè¯
CALL gds.list()
```

### äºŒã€æŠ•å½±å›¾ï¼ˆGraph Projectionï¼‰

```cypher
// 1. åˆ›å»ºå†…å­˜å›¾æŠ•å½±ï¼ˆç”¨äºç®—æ³•ï¼‰
CALL gds.graph.project(
    'social-graph',  // å›¾åç§°
    'Person',        // èŠ‚ç‚¹æ ‡ç­¾
    {
        FRIEND: {    // å…³ç³»ç±»å‹
            orientation: 'UNDIRECTED'  // æ— å‘
        }
    }
)

// 2. æŸ¥çœ‹æŠ•å½±ä¿¡æ¯
CALL gds.graph.list()

// 3. åˆ é™¤æŠ•å½±
CALL gds.graph.drop('social-graph')
```

### ä¸‰ã€ä¸­å¿ƒæ€§ç®—æ³•

#### 1. PageRankï¼ˆé‡è¦æ€§æ’åï¼‰

```cypher
// è®¡ç®—PageRank
CALL gds.pageRank.stream('social-graph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS person, score
ORDER BY score DESC
LIMIT 10

// å†™å›æ•°æ®åº“
CALL gds.pageRank.write('social-graph', {
    writeProperty: 'pagerank'
})

// æŸ¥è¯¢
MATCH (p:Person)
RETURN p.name, p.pagerank
ORDER BY p.pagerank DESC
LIMIT 10
```

#### 2. Betweenness Centralityï¼ˆä¸­ä»‹ä¸­å¿ƒæ€§ï¼‰

```cypher
// è®¡ç®—ä¸­ä»‹ä¸­å¿ƒæ€§ï¼ˆæ¡¥æ¢èŠ‚ç‚¹ï¼‰
CALL gds.betweenness.stream('social-graph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS person, score
ORDER BY score DESC
LIMIT 10
```

#### 3. Degree Centralityï¼ˆåº¦ä¸­å¿ƒæ€§ï¼‰

```cypher
// è®¡ç®—åº¦ä¸­å¿ƒæ€§ï¼ˆè¿æ¥æ•°ï¼‰
CALL gds.degree.stream('social-graph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS person, score
ORDER BY score DESC
LIMIT 10
```

---

### å››ã€ç¤¾åŒºæ£€æµ‹ç®—æ³•

#### 1. Louvainï¼ˆç¤¾åŒºå‘ç°ï¼‰

```cypher
// å‘ç°ç¤¾åŒº
CALL gds.louvain.stream('social-graph')
YIELD nodeId, communityId
WITH gds.util.asNode(nodeId) AS person, communityId
RETURN 
    communityId,
    COLLECT(person.name) as members,
    COUNT(*) as size
ORDER BY size DESC

// å†™å›æ•°æ®åº“
CALL gds.louvain.write('social-graph', {
    writeProperty: 'community'
})

// æŸ¥è¯¢åŒä¸€ç¤¾åŒºçš„äºº
MATCH (p:Person {community: 1})
RETURN p.name, p.company
```

#### 2. Label Propagationï¼ˆæ ‡ç­¾ä¼ æ’­ï¼‰

```cypher
// æ ‡ç­¾ä¼ æ’­ç®—æ³•
CALL gds.labelPropagation.stream('social-graph')
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS person, communityId
ORDER BY communityId
```

---

### äº”ã€ç›¸ä¼¼åº¦ç®—æ³•

#### 1. Node Similarityï¼ˆèŠ‚ç‚¹ç›¸ä¼¼åº¦ï¼‰

```cypher
// è®¡ç®—èŠ‚ç‚¹ç›¸ä¼¼åº¦
CALL gds.nodeSimilarity.stream('social-graph')
YIELD node1, node2, similarity
RETURN 
    gds.util.asNode(node1).name AS person1,
    gds.util.asNode(node2).name AS person2,
    similarity
ORDER BY similarity DESC
LIMIT 10
```

#### 2. Jaccard Similarityï¼ˆJaccardç›¸ä¼¼åº¦ï¼‰

```cypher
// åŸºäºå…±åŒæœ‹å‹çš„Jaccardç›¸ä¼¼åº¦
MATCH (p1:Person {name: "å¼ ä¸‰"})
MATCH (p2:Person)
WHERE p1 <> p2
OPTIONAL MATCH (p1)-[:FRIEND]->(common)<-[:FRIEND]-(p2)
WITH 
    p1, p2,
    COUNT(DISTINCT common) as common_friends,
    SIZE((p1)-[:FRIEND]->()) as p1_friends,
    SIZE((p2)-[:FRIEND]->()) as p2_friends
WITH 
    p1, p2, common_friends,
    (p1_friends + p2_friends - common_friends) as total_friends
RETURN 
    p2.name,
    CASE 
        WHEN total_friends = 0 THEN 0
        ELSE toFloat(common_friends) / total_friends
    END as jaccard_similarity
ORDER BY jaccard_similarity DESC
LIMIT 10
```

---

### å…­ã€è·¯å¾„æŸ¥æ‰¾ç®—æ³•

#### 1. Shortest Pathï¼ˆæœ€çŸ­è·¯å¾„ï¼‰

```cypher
// Dijkstraæœ€çŸ­è·¯å¾„
MATCH (source:Person {name: "å¼ ä¸‰"}), (target:Person {name: "æå››"})
CALL gds.shortestPath.dijkstra.stream('social-graph', {
    sourceNode: source,
    targetNode: target
})
YIELD nodeIds, totalCost
RETURN 
    [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path,
    totalCost
```

#### 2. All Shortest Pathsï¼ˆæ‰€æœ‰æœ€çŸ­è·¯å¾„ï¼‰

```cypher
// æ‰€æœ‰æœ€çŸ­è·¯å¾„
MATCH (source:Person {name: "å¼ ä¸‰"}), (target:Person {name: "æå››"})
CALL gds.allShortestPaths.stream('social-graph', {
    sourceNode: source,
    targetNode: target
})
YIELD nodeIds
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path
```

---

## ğŸ’» å®Œæ•´å®æˆ˜æ¡ˆä¾‹ï¼šäººæ‰æ¨èç³»ç»Ÿ

```python
from neo4j import GraphDatabase
from typing import List, Dict

class TalentRecommender:
    """åŸºäºå›¾ç®—æ³•çš„äººæ‰æ¨èç³»ç»Ÿ"""
    
    def __init__(self, uri, user, password):
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
        self._init_graph_projection()
    
    def _init_graph_projection(self):
        """åˆå§‹åŒ–å›¾æŠ•å½±"""
        with self.driver.session() as session:
            # åˆ é™¤æ—§æŠ•å½±ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            try:
                session.run("CALL gds.graph.drop('talent-graph')")
            except:
                pass
            
            # åˆ›å»ºæ–°æŠ•å½±
            session.run("""
                CALL gds.graph.project(
                    'talent-graph',
                    ['Person', 'Company', 'Skill'],
                    {
                        FRIEND: {orientation: 'UNDIRECTED'},
                        WORKS_AT: {orientation: 'UNDIRECTED'},
                        HAS_SKILL: {orientation: 'UNDIRECTED'}
                    }
                )
            """)
    
    def recommend_by_mutual_friends(
        self,
        person_name: str,
        top_k: int = 10
    ) -> List[Dict]:
        """åŸºäºå…±åŒæœ‹å‹æ¨è"""
        
        with self.driver.session() as session:
            result = session.run("""
                MATCH (me:Person {name: $name})-[:FRIEND]->()-[:FRIEND]->(candidate)
                WHERE NOT (me)-[:FRIEND]->(candidate) AND me <> candidate
                WITH candidate, COUNT(*) as mutual_friends
                ORDER BY mutual_friends DESC
                LIMIT $top_k
                MATCH (candidate)-[:HAS_SKILL]->(skill)
                RETURN 
                    candidate.name as name,
                    mutual_friends,
                    COLLECT(skill.name) as skills
            """, name=person_name, top_k=top_k)
            
            return [dict(record) for record in result]
    
    def recommend_by_similarity(
        self,
        person_name: str,
        top_k: int = 10
    ) -> List[Dict]:
        """åŸºäºèŠ‚ç‚¹ç›¸ä¼¼åº¦æ¨è"""
        
        with self.driver.session() as session:
            # è®¡ç®—ç›¸ä¼¼åº¦
            result = session.run("""
                MATCH (me:Person {name: $name})
                CALL gds.nodeSimilarity.stream('talent-graph')
                YIELD node1, node2, similarity
                WHERE node1 = id(me)
                WITH gds.util.asNode(node2) as candidate, similarity
                WHERE candidate:Person 
                  AND candidate <> me
                  AND NOT (me)-[:FRIEND]->(candidate)
                RETURN 
                    candidate.name as name,
                    similarity
                ORDER BY similarity DESC
                LIMIT $top_k
            """, name=person_name, top_k=top_k)
            
            return [dict(record) for record in result]
    
    def recommend_by_pagerank(
        self,
        skill: str,
        top_k: int = 10
    ) -> List[Dict]:
        """åŸºäºPageRankæ¨èä¸“å®¶"""
        
        with self.driver.session() as session:
            # è®¡ç®—PageRank
            session.run("""
                CALL gds.pageRank.write('talent-graph', {
                    writeProperty: 'pagerank'
                })
            """)
            
            # æŸ¥è¯¢
            result = session.run("""
                MATCH (p:Person)-[:HAS_SKILL]->(s:Skill {name: $skill})
                RETURN 
                    p.name as name,
                    p.pagerank as influence_score,
                    p.company as company
                ORDER BY influence_score DESC
                LIMIT $top_k
            """, skill=skill, top_k=top_k)
            
            return [dict(record) for record in result]
    
    def find_talent_communities(self) -> List[Dict]:
        """å‘ç°äººæ‰ç¤¾åŒº"""
        
        with self.driver.session() as session:
            result = session.run("""
                CALL gds.louvain.stream('talent-graph')
                YIELD nodeId, communityId
                WITH gds.util.asNode(nodeId) as node, communityId
                WHERE node:Person
                WITH communityId, COLLECT(node.name) as members
                WHERE SIZE(members) >= 3
                RETURN 
                    communityId,
                    members,
                    SIZE(members) as size
                ORDER BY size DESC
            """)
            
            return [dict(record) for record in result]
    
    def find_key_connectors(self, top_k: int = 10) -> List[Dict]:
        """æ‰¾åˆ°å…³é”®è¿æ¥è€…ï¼ˆæ¡¥æ¢äººç‰©ï¼‰"""
        
        with self.driver.session() as session:
            result = session.run("""
                CALL gds.betweenness.stream('talent-graph')
                YIELD nodeId, score
                WITH gds.util.asNode(nodeId) as node, score
                WHERE node:Person
                RETURN 
                    node.name as name,
                    score as bridge_score
                ORDER BY bridge_score DESC
                LIMIT $top_k
            """, top_k=top_k)
            
            return [dict(record) for record in result]
    
    def close(self):
        self.driver.close()

# ä½¿ç”¨ç¤ºä¾‹
recommender = TalentRecommender(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="your_password"
)

# 1. åŸºäºå…±åŒæœ‹å‹æ¨è
print("=== åŸºäºå…±åŒæœ‹å‹æ¨è ===")
friends_recs = recommender.recommend_by_mutual_friends("å¼ ä¸‰", top_k=5)
for rec in friends_recs:
    print(f"{rec['name']}: {rec['mutual_friends']}ä¸ªå…±åŒæœ‹å‹, æŠ€èƒ½: {rec['skills']}")

# 2. åŸºäºç›¸ä¼¼åº¦æ¨è
print("\n=== åŸºäºç›¸ä¼¼åº¦æ¨è ===")
sim_recs = recommender.recommend_by_similarity("å¼ ä¸‰", top_k=5)
for rec in sim_recs:
    print(f"{rec['name']}: ç›¸ä¼¼åº¦ {rec['similarity']:.3f}")

# 3. æ¨èæŸæŠ€èƒ½çš„ä¸“å®¶
print("\n=== Pythonä¸“å®¶æ¨è ===")
experts = recommender.recommend_by_pagerank("Python", top_k=5)
for expert in experts:
    print(f"{expert['name']}: å½±å“åŠ› {expert['influence_score']:.4f}, {expert['company']}")

# 4. å‘ç°äººæ‰ç¤¾åŒº
print("\n=== äººæ‰ç¤¾åŒº ===")
communities = recommender.find_talent_communities()
for i, comm in enumerate(communities[:3]):
    print(f"ç¤¾åŒº{i+1} ({comm['size']}äºº): {', '.join(comm['members'])}")

# 5. å…³é”®è¿æ¥è€…
print("\n=== å…³é”®è¿æ¥è€… ===")
connectors = recommender.find_key_connectors(top_k=5)
for connector in connectors:
    print(f"{connector['name']}: æ¡¥æ¢åˆ†æ•° {connector['bridge_score']:.2f}")

recommender.close()
```

---

## ğŸ¯ æœ¬è¯¾å°ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **Cypheré«˜çº§æŸ¥è¯¢ï¼š**
   - å¯å˜é•¿è·¯å¾„
   - å¤æ‚è¿‡æ»¤
   - èšåˆç»Ÿè®¡
   - è·¯å¾„åˆ†æ

2. **Neo4jå›¾ç®—æ³•ï¼š**
   - ä¸­å¿ƒæ€§ï¼šPageRank, Betweenness, Degree
   - ç¤¾åŒºæ£€æµ‹ï¼šLouvain, Label Propagation
   - ç›¸ä¼¼åº¦ï¼šNode Similarity, Jaccard
   - è·¯å¾„ï¼šShortest Path, All Shortest Paths

3. **å®æˆ˜åº”ç”¨ï¼š**
   - æ¨èç³»ç»Ÿ
   - ç¤¾åŒºå‘ç°
   - å½±å“åŠ›åˆ†æ
   - å…³é”®èŠ‚ç‚¹è¯†åˆ«

4. **æœ€ä½³å®è·µï¼š**
   - ä½¿ç”¨å›¾æŠ•å½±æå‡æ€§èƒ½
   - åˆç†é€‰æ‹©ç®—æ³•
   - æ‰¹é‡å¤„ç†ä¼˜åŒ–
   - ç´¢å¼•ä¼˜åŒ–

---

## ğŸ“ è¯¾åä½œä¸š

### ä½œä¸šï¼šæ„å»ºäººæ‰æ¨èç³»ç»Ÿ

**ä»»åŠ¡ï¼š**
åŸºäºçŸ¥è¯†å›¾è°±æ„å»ºå®Œæ•´çš„äººæ‰æ¨èç³»ç»Ÿ

**è¦æ±‚ï¼š**
1. ä½¿ç”¨è‡³å°‘3ç§æ¨èç­–ç•¥ï¼š
   - ååŒè¿‡æ»¤ï¼ˆå…±åŒæœ‹å‹ï¼‰
   - åŸºäºå†…å®¹ï¼ˆæŠ€èƒ½åŒ¹é…ï¼‰
   - å›¾ç®—æ³•ï¼ˆç›¸ä¼¼åº¦/PageRankï¼‰

2. å®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š
   - æ¨èå¯èƒ½è®¤è¯†çš„äºº
   - æ¨èæŸæŠ€èƒ½çš„ä¸“å®¶
   - å‘ç°æŠ€æœ¯ç¤¾åŒº
   - è¯†åˆ«å…³é”®äººç‰©

3. æ€§èƒ½ä¼˜åŒ–ï¼š
   - ä½¿ç”¨å›¾æŠ•å½±
   - æ‰¹é‡æŸ¥è¯¢
   - ç»“æœç¼“å­˜

---

**æŒæ¡Cypheré«˜çº§æŸ¥è¯¢å’Œå›¾ç®—æ³•ï¼Œä½ å°±èƒ½æ·±åº¦æŒ–æ˜çŸ¥è¯†å›¾è°±çš„ä»·å€¼ï¼** ğŸš€

