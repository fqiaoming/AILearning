![企业级项目架构](./images/enterprise.svg)
*图：企业级项目架构*

# 第119课：【实战】智能客服系统

> **本课目标**：构建一个完整的智能客服系统
> 
> **核心技能**：多轮对话、意图识别、情感分析、工单集成
> 
> **学习时长**：90分钟

---

## 📖 口播文案（8分钟）
![Customer Service](./images/customer_service.svg)
*图：Customer Service*


### 🎯 前言

"今天要做的项目：**智能客服系统**

**这是AI落地最成功的场景之一！**

**为什么客服适合AI？**

```
原因1：需求量大
• 每天大量咨询
• 7x24小时服务
• 人工成本高

原因2：问题重复
• 80%是常见问题
• 答案相对固定
• 适合AI处理

原因3：效果明显
• 响应快速
• 准确率高
• 成本降低

原因4：易于衡量
• 满意度
• 解决率
• 响应时间

ROI清晰！
```

**项目背景：**

```
客户：某电商公司
规模：日订单5000+
客服团队：20人
工作强度：高

痛点：
1. 咨询量大
   • 售前咨询
   • 订单查询
   • 售后问题
   • 投诉建议

2. 重复问题多
   • "如何退货？"
   • "物流在哪？"
   • "优惠券怎么用？"
   • 每天回答几百遍

3. 响应时间长
   • 高峰期排队
   • 客户不满意
   • 客服压力大

4. 人力成本高
   • 20人团队
   • 年成本200万
   • 培训成本高
```

**解决方案：**

```
智能客服系统

【核心功能】

1. 智能问答（RAG）
   • 知识库检索
   • 自动回答
   • 准确率>90%

2. 多轮对话
   • 上下文理解
   • 信息收集
   • 流程引导

3. 意图识别
   • 自动分类
   • 智能路由
   • 转人工判断

4. 情感分析
   • 情绪识别
   • 优先级调整
   • 升级机制

5. 工单集成
   • 自动创建工单
   • 工单跟踪
   • 闭环管理

6. 数据分析
   • 热门问题
   • 满意度统计
   • 质量分析
```

**预期效果：**

```
【业务指标】

自动解决率：70%
• 70%问题AI解决
• 30%转人工

响应时间：<3秒
• AI秒回
• 无需排队

服务时间：7x24小时
• 全天候服务
• 无休息

满意度：85%+
• 快速准确
• 体验良好

【成本效益】

人力成本：-60%
• 减少12人
• 年节省120万

人工效率：+200%
• 只处理复杂问题
• 工作量降低

培训成本：-80%
• AI不需培训
• 即时上岗

【质量提升】

回答一致性：100%
• 标准答案
• 不会出错

知识更新：即时
• 更新立即生效
• 全员同步
```

**技术架构：**

```
┌─────────────────────────────────────────┐
│           用户接入层                     │
├──────────┬──────────┬──────────┬────────┤
│  Web聊天 │ 微信客服 │ APP内嵌  │  电话  │
└──────────┴──────────┴──────────┴────────┘
           ↓
┌─────────────────────────────────────────┐
│         对话管理层                       │
│  • 会话管理                              │
│  • 上下文追踪                            │
│  • 多轮对话                              │
└──────────┬──────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│         NLU理解层                        │
│  • 意图识别                              │
│  • 实体提取                              │
│  • 情感分析                              │
└──────────┬──────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│         决策层                           │
│  ├─ RAG问答（知识库）                   │
│  ├─ 规则引擎（流程）                    │
│  ├─ API调用（订单/物流）                │
│  └─ 转人工（复杂问题）                  │
└──────────┬──────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│         执行层                           │
│  • 答案生成                              │
│  • 工单创建                              │
│  • 消息发送                              │
└──────────┬──────────────────────────────┘
           ↓
┌─────────────────────────────────────────┐
│         数据层                           │
│  • 对话历史                              │
│  • 知识库                                │
│  • 工单系统                              │
│  • 用户画像                              │
└─────────────────────────────────────────┘
```

**关键技术点：**

```
1. 多轮对话管理
   • 上下文记忆
   • 状态机管理
   • 槽位填充

2. 意图识别
   • 分类模型
   • 规则匹配
   • 置信度评分

3. 实体提取
   • NER模型
   • 正则表达式
   • 字典匹配

4. 情感分析
   • 情感分类
   • 紧急程度
   • 自动升级

5. 智能路由
   • 问题分类
   • 能力判断
   • 转人工决策
```

**今天这一课，我要带你：**

**第一部分：对话管理**
- 会话状态管理
- 上下文追踪
- 多轮对话

**第二部分：意图识别**
- 意图分类
- 实体提取
- 情感分析

**第三部分：智能路由**
- RAG问答
- 规则引擎
- API调用
- 转人工

**第四部分：工单集成**
- 工单创建
- 状态跟踪
- 闭环管理

打造完整智能客服！"

---

## 📚 第一部分：对话管理系统

### 一、会话管理

```python
from dataclasses import dataclass
from typing import List, Dict, Optional
from datetime import datetime
import uuid

@dataclass
class Message:
    """消息对象"""
    role: str  # user / assistant
    content: str
    timestamp: datetime
    metadata: Dict = None

class ConversationSession:
    """对话会话"""
    
    def __init__(self, user_id: str):
        """初始化"""
        self.session_id = str(uuid.uuid4())
        self.user_id = user_id
        self.messages: List[Message] = []
        self.context: Dict = {}  # 上下文信息
        self.state: str = "active"  # active / waiting / closed
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def add_message(self, role: str, content: str, metadata: Dict = None):
        """
        添加消息
        
        Args:
            role: 角色
            content: 内容
            metadata: 元数据
        """
        message = Message(
            role=role,
            content=content,
            timestamp=datetime.now(),
            metadata=metadata or {}
        )
        
        self.messages.append(message)
        self.updated_at = datetime.now()
    
    def get_context_messages(self, n: int = 5) -> List[Message]:
        """
        获取上下文消息
        
        Args:
            n: 最近N条消息
        
        Returns:
            消息列表
        """
        return self.messages[-n:] if len(self.messages) > n else self.messages
    
    def update_context(self, key: str, value: any):
        """
        更新上下文
        
        Args:
            key: 键
            value: 值
        """
        self.context[key] = value
        self.updated_at = datetime.now()
    
    def get_context(self, key: str, default=None):
        """获取上下文"""
        return self.context.get(key, default)

class SessionManager:
    """会话管理器"""
    
    def __init__(self):
        """初始化"""
        self.sessions: Dict[str, ConversationSession] = {}
        
        print("="*60)
        print("对话会话管理器")
        print("="*60)
    
    def get_or_create_session(self, user_id: str) -> ConversationSession:
        """
        获取或创建会话
        
        Args:
            user_id: 用户ID
        
        Returns:
            会话对象
        """
        
        # 查找活跃会话
        for session in self.sessions.values():
            if session.user_id == user_id and session.state == "active":
                return session
        
        # 创建新会话
        session = ConversationSession(user_id)
        self.sessions[session.session_id] = session
        
        print(f"✓ 创建新会话：{session.session_id[:8]}... (用户:{user_id})")
        return session
    
    def close_session(self, session_id: str):
        """
        关闭会话
        
        Args:
            session_id: 会话ID
        """
        if session_id in self.sessions:
            self.sessions[session_id].state = "closed"
            print(f"✓ 会话已关闭：{session_id[:8]}...")
    
    def demo(self):
        """演示功能"""
        
        print("\n" + "="*60)
        print("对话管理演示")
        print("="*60)
        
        # 创建会话
        session = self.get_or_create_session("user_123")
        
        # 模拟对话
        print("\n模拟对话：")
        
        # 用户消息1
        session.add_message("user", "你好，我想退货")
        print(f"  用户：我想退货")
        
        # 系统消息1
        session.add_message("assistant", "好的，请问您的订单号是？")
        session.update_context("intent", "退货")
        session.update_context("step", "collect_order_id")
        print(f"  客服：请问您的订单号是？")
        
        # 用户消息2
        session.add_message("user", "订单号是123456")
        session.update_context("order_id", "123456")
        print(f"  用户：订单号是123456")
        
        # 系统消息2
        session.add_message("assistant", "已找到订单，商品是XX手机。请问退货原因？")
        session.update_context("step", "collect_reason")
        print(f"  客服：已找到订单，商品是XX手机。请问退货原因？")
        
        # 显示上下文
        print(f"\n当前上下文：")
        print(f"  意图：{session.get_context('intent')}")
        print(f"  步骤：{session.get_context('step')}")
        print(f"  订单号：{session.get_context('order_id')}")
        
        print(f"\n对话轮数：{len(session.messages)}")
        print(f"会话状态：{session.state}")

# 演示
manager = SessionManager()
manager.demo()
```

---

## 💻 第二部分：意图识别与NLU

### 一、意图识别系统

```python
from typing import List, Tuple
import re

class IntentClassifier:
    """意图识别器"""
    
    def __init__(self):
        """初始化"""
        
        # 意图关键词（实际应使用分类模型）
        self.intent_patterns = {
            "退货退款": ["退货", "退款", "不想要", "退掉"],
            "订单查询": ["订单", "查订单", "在哪", "物流"],
            "产品咨询": ["介绍", "参数", "配置", "怎么样", "评价"],
            "优惠活动": ["优惠", "折扣", "活动", "券", "便宜"],
            "投诉建议": ["投诉", "差评", "不满意", "建议"],
            "账号问题": ["登录", "密码", "账号", "注册"],
            "其他": []
        }
        
        print("="*60)
        print("意图识别系统")
        print("="*60)
        print(f"支持意图：{len(self.intent_patterns)}个")
    
    def classify(self, text: str) -> Tuple[str, float]:
        """
        分类意图
        
        Args:
            text: 用户输入
        
        Returns:
            (意图, 置信度)
        """
        
        text_lower = text.lower()
        
        # 规则匹配（实际应使用模型）
        for intent, keywords in self.intent_patterns.items():
            for keyword in keywords:
                if keyword in text_lower:
                    return intent, 0.9  # 置信度
        
        # 默认意图
        return "其他", 0.5
    
    def extract_entities(self, text: str, intent: str) -> Dict:
        """
        提取实体
        
        Args:
            text: 文本
            intent: 意图
        
        Returns:
            实体字典
        """
        
        entities = {}
        
        # 订单号提取
        order_pattern = r'(\d{6,})'
        order_match = re.search(order_pattern, text)
        if order_match:
            entities['order_id'] = order_match.group(1)
        
        # 手机号提取
        phone_pattern = r'1[3-9]\d{9}'
        phone_match = re.search(phone_pattern, text)
        if phone_match:
            entities['phone'] = phone_match.group(0)
        
        # 根据意图提取特定实体
        if intent == "产品咨询":
            # 提取产品名称
            products = ["手机", "电脑", "平板", "耳机"]
            for product in products:
                if product in text:
                    entities['product'] = product
                    break
        
        return entities
    
    def analyze_sentiment(self, text: str) -> Tuple[str, float]:
        """
        情感分析
        
        Args:
            text: 文本
        
        Returns:
            (情感, 强度)
        """
        
        # 负面关键词
        negative_words = ["不满意", "差", "烂", "垃圾", "投诉", "退款"]
        negative_count = sum(1 for word in negative_words if word in text)
        
        # 正面关键词
        positive_words = ["好", "满意", "不错", "喜欢", "谢谢"]
        positive_count = sum(1 for word in positive_words if word in text)
        
        if negative_count > positive_count:
            sentiment = "negative"
            intensity = min(negative_count * 0.3, 1.0)
        elif positive_count > negative_count:
            sentiment = "positive"
            intensity = min(positive_count * 0.3, 1.0)
        else:
            sentiment = "neutral"
            intensity = 0.5
        
        return sentiment, intensity
    
    def demo(self):
        """演示功能"""
        
        print("\n" + "="*60)
        print("意图识别演示")
        print("="*60)
        
        test_cases = [
            "你好，我想退货",
            "订单号123456在哪里？",
            "这个手机怎么样？",
            "有什么优惠活动吗？",
            "这个产品太差了，我要投诉！"
        ]
        
        for text in test_cases:
            print(f"\n输入：{text}")
            
            # 意图识别
            intent, confidence = self.classify(text)
            print(f"  意图：{intent} (置信度:{confidence:.2f})")
            
            # 实体提取
            entities = self.extract_entities(text, intent)
            if entities:
                print(f"  实体：{entities}")
            
            # 情感分析
            sentiment, intensity = self.analyze_sentiment(text)
            print(f"  情感：{sentiment} (强度:{intensity:.2f})")

# 演示
classifier = IntentClassifier()
classifier.demo()
```

---

## 🎯 第三部分：智能路由与响应

### 一、智能路由系统

```python
class SmartRouter:
    """智能路由系统"""
    
    def __init__(self):
        """初始化"""
        
        self.rag_system = None  # RAG问答系统
        self.rule_engine = None  # 规则引擎
        self.api_client = None   # API客户端
        
        print("="*60)
        print("智能路由系统")
        print("="*60)
    
    def route(
        self,
        intent: str,
        entities: Dict,
        context: Dict
    ) -> Dict:
        """
        路由决策
        
        Args:
            intent: 意图
            entities: 实体
            context: 上下文
        
        Returns:
            响应结果
        """
        
        print(f"\n路由决策：")
        print(f"  意图：{intent}")
        print(f"  实体：{entities}")
        
        # 根据意图路由
        if intent == "订单查询":
            return self._handle_order_query(entities)
        
        elif intent == "退货退款":
            return self._handle_refund(entities, context)
        
        elif intent == "产品咨询":
            return self._handle_product_qa(entities)
        
        elif intent == "优惠活动":
            return self._handle_promotion()
        
        elif intent == "投诉建议":
            return self._handle_complaint(entities)
        
        else:
            return self._handle_general_qa(entities)
    
    def _handle_order_query(self, entities: Dict) -> Dict:
        """处理订单查询"""
        
        print("  → 路由到：订单查询API")
        
        order_id = entities.get('order_id')
        
        if not order_id:
            return {
                "type": "ask",
                "content": "请提供您的订单号",
                "need_info": "order_id"
            }
        
        # 调用订单API（示例）
        # order = self.api_client.get_order(order_id)
        
        return {
            "type": "answer",
            "content": f"您的订单{order_id}已发货，预计明天送达",
            "data": {
                "order_id": order_id,
                "status": "shipped"
            }
        }
    
    def _handle_refund(self, entities: Dict, context: Dict) -> Dict:
        """处理退货退款"""
        
        print("  → 路由到：退货流程")
        
        # 检查槽位
        order_id = entities.get('order_id') or context.get('order_id')
        reason = entities.get('reason') or context.get('reason')
        
        if not order_id:
            return {
                "type": "ask",
                "content": "请提供您的订单号",
                "need_info": "order_id"
            }
        
        if not reason:
            return {
                "type": "ask",
                "content": "请问退货原因是什么？",
                "need_info": "reason"
            }
        
        # 创建退货工单
        return {
            "type": "action",
            "content": "已为您创建退货工单，工单号：WO123456",
            "action": "create_ticket",
            "data": {
                "ticket_id": "WO123456",
                "type": "refund",
                "order_id": order_id,
                "reason": reason
            }
        }
    
    def _handle_product_qa(self, entities: Dict) -> Dict:
        """处理产品咨询"""
        
        print("  → 路由到：RAG问答")
        
        # 调用RAG系统
        # result = self.rag_system.query(query)
        
        return {
            "type": "answer",
            "content": "这款手机配置很高，性价比不错...",
            "sources": ["产品介绍文档", "用户评价"]
        }
    
    def _handle_promotion(self) -> Dict:
        """处理优惠活动"""
        
        print("  → 路由到：活动查询API")
        
        return {
            "type": "answer",
            "content": "当前活动：全场满300减50，点击查看详情",
            "data": {
                "promotions": [
                    {"name": "满减活动", "rule": "满300减50"}
                ]
            }
        }
    
    def _handle_complaint(self, entities: Dict) -> Dict:
        """处理投诉"""
        
        print("  → 路由到：转人工")
        
        # 高优先级，转人工
        return {
            "type": "transfer",
            "content": "非常抱歉给您带来不便，正在为您转接人工客服...",
            "reason": "complaint",
            "priority": "high"
        }
    
    def _handle_general_qa(self, entities: Dict) -> Dict:
        """处理通用问答"""
        
        print("  → 路由到：RAG问答")
        
        return {
            "type": "answer",
            "content": "根据您的问题，推荐您查看帮助文档...",
            "sources": []
        }
    
    def should_transfer(
        self,
        intent: str,
        sentiment: str,
        confidence: float
    ) -> Tuple[bool, str]:
        """
        判断是否转人工
        
        Args:
            intent: 意图
            sentiment: 情感
            confidence: 置信度
        
        Returns:
            (是否转人工, 原因)
        """
        
        # 规则1：投诉必转
        if intent == "投诉建议":
            return True, "投诉"
        
        # 规则2：情绪激动转人工
        if sentiment == "negative":
            return True, "情绪负面"
        
        # 规则3：置信度低转人工
        if confidence < 0.6:
            return True, "置信度低"
        
        # 规则4：多轮无法解决
        # if context.get('retry_count', 0) > 2:
        #     return True, "多轮未解决"
        
        return False, ""

# 演示
router = SmartRouter()

# 测试路由
result = router.route(
    intent="订单查询",
    entities={"order_id": "123456"},
    context={}
)
print(f"\n响应：{result['content']}")
```

---

## 📝 课后练习

### 练习1：对话管理
实现完整的对话状态机

### 练习2：意图识别
训练意图分类模型

### 练习3：工单集成
对接工单系统

---

## 🎓 知识总结

### 核心要点

1. **对话管理**
   - 会话状态
   - 上下文追踪
   - 多轮对话

2. **意图识别**
   - 分类准确
   - 实体提取
   - 情感分析

3. **智能路由**
   - RAG问答
   - API调用
   - 转人工决策

4. **工单集成**
   - 自动创建
   - 状态跟踪
   - 闭环管理

---

## 🚀 下节预告

下一课：**第120课：综合实战总结与提升**

- 项目经验总结
- 技能提升建议
- 面试准备指南
- 职业发展规划

**第19章完美收官！** 🔥

---

**💪 记住：智能客服是AI落地的最佳场景！**

**下一课见！** 🎉
