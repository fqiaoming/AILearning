![监控与性能分析](./images/monitoring.svg)
*图：监控与性能分析*

# 第40课：监控告警系统实战 - 第二模块完美收官

> 📚 **课程信息**
> - 所属模块：第二模块 - API与LangChain开发  
> - 章节：第7章 - LangChain调试与监控（第4/4课 - 完结）
> - 学习目标：构建完整的生产级监控告警系统
> - 预计时间：120-150分钟
> - 前置知识：第16-39课

---

## 📢 课程导入

### 前言

凌晨2点，你的AI系统突然崩了！用户疯狂投诉，老板疯狂打电话，但你却在睡梦中毫不知情...等你早上起床发现时，损失已经无法挽回！

**这就是没有监控告警的后果！**在生产环境，**"不知道出问题"比"出问题"更可怕！**一个完善的监控告警系统能在故障发生的第一时间通知你，甚至在故障发生前就发出预警！

今天这课是第二模块的压轴大戏！我们要把前24课学的所有知识整合起来，构建一个**完整的、生产级的、可随时上线的监控告警系统**！

---

### 核心价值点

**第一，监控告警是生产系统的生命线。**

没有监控的系统就像：
- 闭着眼睛开车
- 不看仪表盘的飞行员
- 不测血压的病人

**你永远不知道系统什么时候会出问题！**

有了监控告警：
- ✅ 实时掌握系统状态
- ✅ 第一时间发现异常
- ✅ 快速定位问题
- ✅ 预防性维护

**第二，这是第二模块25课知识的完美整合。**

回顾我们学过的：
- 第16-21课：API调用基础
- 第22-29课：LangChain框架
- 第30-36课：Chain高级应用
- 第37-39课：调试、日志、性能分析

今天的监控系统会用到：
- ✅ Callback（第33课）
- ✅ 日志系统（第38课）
- ✅ 性能分析（第39课）
- ✅ 错误处理（第19课）
- ✅ LangSmith（第37课）

**这是知识融会贯通的最佳实践！**

**第三，这是可以直接用于生产的完整项目。**

不是玩具demo，而是包含：
- ✅ 实时性能监控
- ✅ 错误率统计
- ✅ 成本追踪
- ✅ 多级告警
- ✅ 可视化面板
- ✅ 历史数据分析

**这就是企业真实使用的监控系统！**

**第四，这是第二模块的完美收官。**

25课学完，你已经掌握：
- API调用和优化
- LangChain完整开发
- Chain高级应用
- Memory管理
- 调试和监控

**你现在具备了开发企业级LangChain应用的所有能力！**

---

### 行动号召

今天这一课我们将：
- 设计完整的监控架构
- 实现多维度指标监控
- 构建多级告警系统
- 开发可视化监控面板
- 第二模块知识总结

**这是25课的终极实战！学完你就能独立开发生产级系统！**

---

## 📖 系统设计

### 1. 监控架构

```
用户请求
   ↓
┌──────────────────────────────────┐
│   LangChain Application          │
│  (带Callback监控)                │
└──────────────────────────────────┘
   ↓
┌──────────────────────────────────┐
│   监控数据收集层                 │
│  - 性能指标                      │
│  - 错误日志                      │
│  - 业务指标                      │
└──────────────────────────────────┘
   ↓
┌──────────────────────────────────┐
│   数据存储层                     │
│  - 时序数据库（指标）            │
│  - 日志存储（JSON）              │
└──────────────────────────────────┘
   ↓
┌──────────────────────────────────┐
│   告警判断层                     │
│  - 规则引擎                      │
│  - 阈值检测                      │
│  - 异常检测                      │
└──────────────────────────────────┘
   ↓
┌──────────────────────────────────┐
│   告警通知层                     │
│  - 邮件                          │
│  - 短信                          │
│  - Webhook                       │
└──────────────────────────────────┘
   ↓
┌──────────────────────────────────┐
│   可视化展示层                   │
│  - 实时监控面板                  │
│  - 历史趋势图                    │
│  - 告警历史                      │
└──────────────────────────────────┘
```

---


![Alerting](./images/alerting.svg)
*图：Alerting*

### 2. 监控指标

```python
# 核心指标
METRICS = {
    "性能指标": {
        "响应时间": ["avg", "p50", "p95", "p99"],
        "QPS": ["当前", "峰值"],
        "并发数": ["当前", "峰值"]
    },
    "质量指标": {
        "成功率": ["百分比"],
        "错误率": ["百分比"],
        "超时率": ["百分比"]
    },
    "资源指标": {
        "LLM调用": ["次数", "耗时"],
        "Token使用": ["prompt", "completion", "total"],
        "成本": ["单次", "总计"]
    },
    "业务指标": {
        "用户数": ["活跃用户"],
        "请求类型": ["分布"],
        "热门查询": ["Top 10"]
    }
}
```

---

## 💻 完整系统实现

创建`monitoring_system.py`：

```python
"""
生产级监控告警系统
第二模块终极实战项目
"""

import time
import json
import uuid
from datetime import datetime
from typing import Dict, List, Optional
from collections import defaultdict, deque
from dataclasses import dataclass, asdict
from pathlib import Path

from langchain.callbacks.base import BaseCallbackHandler
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain.schema.output_parser import StrOutputParser


# ============= 1. 数据模型 =============

@dataclass
class RequestMetrics:
    """单次请求的指标"""
    request_id: str
    timestamp: datetime
    user_id: Optional[str]
    success: bool
    response_time: float
    llm_calls: int
    llm_time: float
    tokens: Dict[str, int]
    error: Optional[str] = None
    
    def to_dict(self):
        """转换为字典"""
        data = asdict(self)
        data['timestamp'] = self.timestamp.isoformat()
        return data


# ============= 2. 监控收集器 =============

class MonitoringCollector(BaseCallbackHandler):
    """监控数据收集器"""
    
    def __init__(self, request_id: str, user_id: Optional[str] = None):
        self.request_id = request_id
        self.user_id = user_id
        self.start_time = None
        self.metrics = {
            "llm_calls": 0,
            "llm_time": 0,
            "tokens": {"prompt": 0, "completion": 0, "total": 0},
            "success": True,
            "error": None
        }
        self.start_times = {}
    
    def on_chain_start(self, serialized, inputs, **kwargs):
        """Chain开始"""
        self.start_time = time.time()
    
    def on_chain_end(self, outputs, **kwargs):
        """Chain成功完成"""
        self.metrics["success"] = True
    
    def on_chain_error(self, error, **kwargs):
        """Chain错误"""
        self.metrics["success"] = False
        self.metrics["error"] = str(error)
    
    def on_llm_start(self, serialized, prompts, **kwargs):
        """LLM开始"""
        run_id = kwargs.get("run_id")
        self.start_times[f"llm_{run_id}"] = time.time()
        self.metrics["llm_calls"] += 1
    
    def on_llm_end(self, response, **kwargs):
        """LLM完成"""
        run_id = kwargs.get("run_id")
        key = f"llm_{run_id}"
        
        if key in self.start_times:
            elapsed = time.time() - self.start_times[key]
            self.metrics["llm_time"] += elapsed
        
        # Token统计
        if hasattr(response, 'llm_output'):
            usage = response.llm_output.get('token_usage', {})
            self.metrics["tokens"]["prompt"] += usage.get('prompt_tokens', 0)
            self.metrics["tokens"]["completion"] += usage.get('completion_tokens', 0)
            self.metrics["tokens"]["total"] += usage.get('total_tokens', 0)
    
    def get_metrics(self) -> RequestMetrics:
        """获取指标"""
        response_time = time.time() - self.start_time if self.start_time else 0
        
        return RequestMetrics(
            request_id=self.request_id,
            timestamp=datetime.now(),
            user_id=self.user_id,
            success=self.metrics["success"],
            response_time=response_time,
            llm_calls=self.metrics["llm_calls"],
            llm_time=self.metrics["llm_time"],
            tokens=self.metrics["tokens"],
            error=self.metrics["error"]
        )


# ============= 3. 监控存储 =============

class MetricsStorage:
    """指标存储（内存+文件）"""
    
    def __init__(self, storage_dir: str = "monitoring_data"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(exist_ok=True)
        
        # 内存中保留最近的数据
        self.recent_requests = deque(maxlen=1000)
        self.hourly_stats = defaultdict(lambda: {
            "count": 0,
            "success": 0,
            "total_time": 0,
            "total_tokens": 0
        })
    
    def save_request(self, metrics: RequestMetrics):
        """保存请求指标"""
        # 内存
        self.recent_requests.append(metrics)
        
        # 更新hourly stats
        hour_key = metrics.timestamp.strftime("%Y-%m-%d_%H")
        stats = self.hourly_stats[hour_key]
        stats["count"] += 1
        if metrics.success:
            stats["success"] += 1
        stats["total_time"] += metrics.response_time
        stats["total_tokens"] += metrics.tokens["total"]
        
        # 文件
        date_key = metrics.timestamp.strftime("%Y-%m-%d")
        log_file = self.storage_dir / f"requests_{date_key}.jsonl"
        
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(metrics.to_dict(), ensure_ascii=False) + '\n')
    
    def get_recent_stats(self, minutes: int = 5) -> Dict:
        """获取最近N分钟的统计"""
        cutoff = datetime.now().timestamp() - minutes * 60
        
        recent = [
            m for m in self.recent_requests
            if m.timestamp.timestamp() > cutoff
        ]
        
        if not recent:
            return {}
        
        response_times = [m.response_time for m in recent]
        response_times.sort()
        
        success_count = sum(1 for m in recent if m.success)
        total_count = len(recent)
        
        return {
            "total_requests": total_count,
            "success_rate": success_count / total_count * 100,
            "avg_response_time": sum(response_times) / len(response_times),
            "p50": response_times[int(len(response_times) * 0.5)],
            "p95": response_times[int(len(response_times) * 0.95)],
            "p99": response_times[int(len(response_times) * 0.99)],
            "qps": total_count / (minutes * 60),
            "total_tokens": sum(m.tokens["total"] for m in recent),
            "total_cost": sum(m.tokens["total"] for m in recent) * 0.0005 / 1000
        }


# ============= 4. 告警引擎 =============

class AlertRule:
    """告警规则"""
    
    def __init__(self, name: str, metric: str, threshold: float, 
                 condition: str, severity: str):
        self.name = name
        self.metric = metric
        self.threshold = threshold
        self.condition = condition  # '>', '<', '>=', '<='
        self.severity = severity  # 'warning', 'error', 'critical'
    
    def check(self, value: float) -> bool:
        """检查是否触发"""
        if self.condition == '>':
            return value > self.threshold
        elif self.condition == '<':
            return value < self.threshold
        elif self.condition == '>=':
            return value >= self.threshold
        elif self.condition == '<=':
            return value <= self.threshold
        return False


class AlertEngine:
    """告警引擎"""
    
    def __init__(self):
        self.rules = []
        self.alerts = []
        self._setup_default_rules()
    
    def _setup_default_rules(self):
        """设置默认告警规则"""
        self.rules = [
            AlertRule("响应时间过慢", "avg_response_time", 5.0, '>', "warning"),
            AlertRule("响应时间严重慢", "avg_response_time", 10.0, '>', "critical"),
            AlertRule("成功率过低", "success_rate", 95.0, '<', "warning"),
            AlertRule("成功率严重低", "success_rate", 90.0, '<', "critical"),
            AlertRule("P95响应时间高", "p95", 8.0, '>', "warning"),
            AlertRule("成本过高", "total_cost", 1.0, '>', "warning"),
        ]
    
    def check_metrics(self, stats: Dict):
        """检查指标，触发告警"""
        triggered = []
        
        for rule in self.rules:
            if rule.metric in stats:
                value = stats[rule.metric]
                if rule.check(value):
                    alert = {
                        "timestamp": datetime.now().isoformat(),
                        "rule": rule.name,
                        "metric": rule.metric,
                        "value": value,
                        "threshold": rule.threshold,
                        "severity": rule.severity
                    }
                    triggered.append(alert)
                    self.alerts.append(alert)
        
        return triggered
    
    def send_alert(self, alert: Dict):
        """发送告警（这里只打印，实际可以发邮件/短信/Webhook）"""
        severity_emoji = {
            "warning": "⚠️",
            "error": "❌",
            "critical": "🚨"
        }
        
        emoji = severity_emoji.get(alert["severity"], "⚠️")
        
        print(f"\n{emoji} 告警触发！")
        print(f"  规则：{alert['rule']}")
        print(f"  指标：{alert['metric']}")
        print(f"  当前值：{alert['value']:.2f}")
        print(f"  阈值：{alert['threshold']:.2f}")
        print(f"  级别：{alert['severity'].upper()}")
        print(f"  时间：{alert['timestamp']}\n")


# ============= 5. 监控系统主类 =============

class MonitoringSystem:
    """完整的监控系统"""
    
    def __init__(self, storage_dir: str = "monitoring_data"):
        self.storage = MetricsStorage(storage_dir)
        self.alert_engine = AlertEngine()
        
        print("✓ 监控系统初始化完成")
        print(f"  数据存储：{storage_dir}/")
        print(f"  告警规则：{len(self.alert_engine.rules)}条\n")
    
    def create_collector(self, user_id: Optional[str] = None) -> MonitoringCollector:
        """创建监控收集器"""
        request_id = str(uuid.uuid4())
        return MonitoringCollector(request_id, user_id)
    
    def record_request(self, collector: MonitoringCollector):
        """记录请求"""
        metrics = collector.get_metrics()
        self.storage.save_request(metrics)
    
    def check_alerts(self):
        """检查告警"""
        stats = self.storage.get_recent_stats(minutes=5)
        
        if not stats:
            return []
        
        triggered = self.alert_engine.check_metrics(stats)
        
        for alert in triggered:
            self.alert_engine.send_alert(alert)
        
        return triggered
    
    def get_dashboard(self) -> str:
        """获取监控面板"""
        stats = self.storage.get_recent_stats(minutes=5)
        
        if not stats:
            return "暂无数据"
        
        dashboard = f"""
╔════════════════════════════════════════════════════════════╗
║                    监控面板（最近5分钟）                   ║
╠════════════════════════════════════════════════════════════╣
║ 请求总数：{stats['total_requests']:>6}
║ 成功率：  {stats['success_rate']:>5.1f}%
║ QPS：     {stats['qps']:>5.1f}
║────────────────────────────────────────────────────────────
║ 响应时间：
║   平均：  {stats['avg_response_time']:>5.2f}秒
║   P50：   {stats['p50']:>5.2f}秒
║   P95：   {stats['p95']:>5.2f}秒
║   P99：   {stats['p99']:>5.2f}秒
║────────────────────────────────────────────────────────────
║ 资源使用：
║   Token：  {stats['total_tokens']:>6}
║   成本：   ${stats['total_cost']:>5.4f}
╚════════════════════════════════════════════════════════════╝
"""
        return dashboard


# ============= 6. Demo演示 =============

def demo_monitoring_system():
    """演示完整的监控系统"""
    
    print("\n" + "="*60)
    print("🎯 生产级监控告警系统演示")
    print("="*60 + "\n")
    
    # 初始化监控系统
    monitoring = MonitoringSystem()
    
    # 初始化Chain
    llm = ChatOpenAI()
    prompt = ChatPromptTemplate.from_template("用一句话解释{topic}")
    chain = prompt | llm | StrOutputParser()
    
    # 模拟多个请求
    test_cases = [
        {"topic": "人工智能", "user": "user_001"},
        {"topic": "机器学习", "user": "user_002"},
        {"topic": "深度学习", "user": "user_001"},
        {"topic": "强化学习", "user": "user_003"},
        {"topic": "自然语言处理", "user": "user_002"},
    ]
    
    print("开始处理请求...\n")
    
    for i, test in enumerate(test_cases, 1):
        print(f"[{i}/{len(test_cases)}] 处理请求...")
        
        # 创建监控收集器
        collector = monitoring.create_collector(user_id=test["user"])
        
        try:
            # 执行Chain
            result = chain.invoke(
                {"topic": test["topic"]},
                config={"callbacks": [collector]}
            )
            
            print(f"  用户：{test['user']}")
            print(f"  查询：{test['topic']}")
            print(f"  结果：{result[:50]}...")
            
        except Exception as e:
            print(f"  ❌ 错误：{e}")
        
        finally:
            # 记录指标
            monitoring.record_request(collector)
            print(f"  ✓ 指标已记录\n")
        
        # 每2个请求检查一次告警
        if i % 2 == 0:
            monitoring.check_alerts()
    
    # 显示监控面板
    print("\n" + "="*60)
    dashboard = monitoring.get_dashboard()
    print(dashboard)
    
    # 显示告警历史
    if monitoring.alert_engine.alerts:
        print("告警历史：")
        for alert in monitoring.alert_engine.alerts:
            print(f"  [{alert['severity']}] {alert['rule']} - {alert['value']:.2f}")
    else:
        print("✓ 无告警触发")
    
    print("\n" + "="*60)
    print("✅ 演示完成！")
    print("="*60)


# ============= 第二模块总结 =============

def print_module_summary():
    """打印第二模块学习总结"""
    
    summary = """

╔════════════════════════════════════════════════════════════╗
║               🎊 第二模块完美收官！🎊                    ║
╠════════════════════════════════════════════════════════════╣
║  模块名称：API调用与LangChain开发（25课）                ║
║  课程范围：第16-40课                                      ║
║  学习时长：4-7周                                          ║
╚════════════════════════════════════════════════════════════╝

📚 知识体系回顾：

第4章：大模型API开发（6课）
  ✓ 第16课：本地模型API调用
  ✓ 第17课：Function Calling
  ✓ 第18课：Streaming与异步
  ✓ 第19课：错误处理与重试
  ✓ 第20课：Token管理
  ✓ 第21课：API安全

第5章：LangChain框架精通（8课）
  ✓ 第22课：API调用最佳实践
  ✓ 第23课：LangChain核心概念
  ✓ 第24课：Prompt Template
  ✓ 第25课：Output Parser
  ✓ 第26课：Model管理
  ✓ 第27课：Chain与LCEL
  ✓ 第28课：LangChain实战
  ✓ 第29课：核心概念总结

第6章：Chain高级应用（7课）
  ✓ 第30课：SequentialChain
  ✓ 第31课：RouterChain
  ✓ 第32课：Memory深入
  ✓ 第33课：Callback监控
  ✓ 第34课：调试技巧
  ✓ 第35课：性能优化
  ✓ 第36课：综合实战项目

第7章：调试与监控（4课）
  ✓ 第37课：LangSmith可视化
  ✓ 第38课：生产级日志
  ✓ 第39课：性能分析
  ✓ 第40课：监控告警系统（本课）

═══════════════════════════════════════════════════════════

🎯 核心能力达成：

技术能力：
  ✅ 熟练使用LangChain框架开发
  ✅ 掌握Chain组合和编排
  ✅ 精通Memory和上下文管理
  ✅ 会使用Callback监控系统
  ✅ 能进行性能分析和优化
  ✅ 具备完整的调试能力

工程能力：
  ✅ API调用和错误处理
  ✅ 日志系统设计
  ✅ 监控告警实现
  ✅ 性能优化策略
  ✅ 生产环境最佳实践

项目经验：
  ✅ 智能内容处理系统（第36课）
  ✅ 监控告警系统（第40课）
  ✅ 多个实战demo

═══════════════════════════════════════════════════════════

🚀 下一步学习：

第三模块：向量数据库与RAG系统（30课）
  - 向量数据库原理
  - Embedding技术
  - RAG系统开发
  - 知识库构建
  - 高级RAG技术

即将开启更高级的AI应用开发！

═══════════════════════════════════════════════════════════

💡 学习建议：

1. 复习巩固：
   - 重做第36、40课的实战项目
   - 尝试优化和扩展功能
   - 形成自己的代码库

2. 实践应用：
   - 用学到的知识开发小项目
   - 尝试解决实际问题
   - 积累项目经验

3. 持续学习：
   - 关注LangChain更新
   - 学习优秀开源项目
   - 参与社区讨论

═══════════════════════════════════════════════════════════

🎉 恭喜你完成第二模块！

你已经具备了开发企业级LangChain应用的核心能力！

进度：40/165课（24.2%完成）

准备好迎接第三模块的挑战了吗？ 🚀

═══════════════════════════════════════════════════════════
"""
    
    print(summary)


# ============= 主函数 =============

def main():
    """主函数"""
    
    # 运行监控系统演示
    demo_monitoring_system()
    
    # 打印模块总结
    print_module_summary()


if __name__ == "__main__":
    main()
```

---

## 🎯 系统特点

### 完整功能

```
✅ 数据收集：通过Callback自动收集
✅ 数据存储：内存+文件持久化
✅ 实时监控：最近N分钟统计
✅ 告警引擎：规则匹配+多级告警
✅ 可视化：ASCII面板展示
✅ 历史分析：按天存储JSONL
```

### 扩展方向

```
1. 数据库集成：
   - PostgreSQL存储指标
   - Redis缓存热数据
   - InfluxDB时序数据

2. 可视化增强：
   - Grafana仪表盘
   - 实时图表
   - 趋势分析

3. 告警通知：
   - Email（SMTP）
   - 短信（Twilio）
   - Slack/钉钉Webhook
   - PagerDuty集成

4. 分析功能：
   - 异常检测（机器学习）
   - 预测性告警
   - 根因分析

5. 分布式：
   - 多实例监控
   - 聚合统计
   - 集中式告警
```

---

## ✅ 第二模块完结

### 学习成果

完成第二模块（25课）后，你已经掌握：

- [ ] API调用和优化技巧
- [ ] LangChain完整开发能力
- [ ] Chain组合和编排
- [ ] Memory和上下文管理
- [ ] Callback监控系统
- [ ] 调试和性能分析
- [ ] 日志系统设计
- [ ] 监控告警实现
- [ ] 2个完整的实战项目

---

## 📝 下一步学习

**第三模块：向量数据库与RAG系统（第41-70课，30课）**

下个模块我们将学习：
- 向量数据库原理
- Embedding技术
- 文档处理工程化
- RAG系统完整开发
- 高级RAG技术
- 知识库构建

**从LangChain基础迈向AI应用的核心技术！**

---

**🎊 恭喜你完成第二模块！🎊**

**25课学完，你已经具备企业级LangChain开发能力！**

**进度：40/165课（24.2%完成）** 🚀

**休息一下，准备迎接更高级的挑战！** 💪
