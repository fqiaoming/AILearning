![Tool Calling流程](./images/tool_calling.svg)
*图：Tool Calling流程*

# 第80课：自定义工具开发-数据库操作

> **本课目标**：掌握数据库操作工具的开发，让Agent能够读写数据库
> 
> **核心技能**：SQL封装、参数化查询、安全防护、连接池管理
> 
> **实战案例**：构建数据库查询Agent
> 
> **学习时长**：85分钟

---

## 📖 口播文案（5分钟）
![Tool Chain](./images/tool_chain.svg)
*图：Tool Chain*


### 🎯 前言

"上节课我们学习了API封装。

今天我们要学习更强大的能力：**让Agent操作数据库！**

**为什么需要数据库操作？**

看几个真实场景：

**场景1：数据查询助手**
```
用户："帮我查一下上个月的销售额"

没有数据库：
"抱歉，我没有数据..."

有数据库工具：
SELECT SUM(amount) FROM sales 
WHERE date >= '2024-10-01' 
AND date < '2024-11-01'

→ 结果：￥1,234,567

✅ 实时准确！
```

**场景2：客户管理助手**
```
用户："有多少VIP客户？"

Agent自动查询：
SELECT COUNT(*) FROM customers 
WHERE level = 'VIP'

→ 结果：1,234个VIP客户

✅ 即时响应！
```

**场景3：数据分析助手**
```
用户："哪个地区销售最好？"

Agent智能分析：
SELECT region, SUM(amount) as total
FROM sales
GROUP BY region
ORDER BY total DESC
LIMIT 1

→ 结果：华东地区，￥5,678,901

✅ 智能分析！
```

**数据库操作的关键挑战：**

**挑战1：SQL注入风险**
```python
❌ 危险方式：
query = f"SELECT * FROM users WHERE name='{user_input}'"
# 如果user_input是 "admin' OR '1'='1"
# 查询变成：SELECT * FROM users WHERE name='admin' OR '1'='1'
# 返回所有用户！危险！

✅ 安全方式：
query = "SELECT * FROM users WHERE name=?"
cursor.execute(query, (user_input,))
# 参数化查询，自动转义
```

**挑战2：权限控制**
```python
# 需要限制Agent能执行的操作
ALLOWED_OPERATIONS = ['SELECT', 'INSERT', 'UPDATE']
FORBIDDEN_OPERATIONS = ['DROP', 'DELETE', 'TRUNCATE']

# 检查SQL是否安全
if any(op in sql.upper() for op in FORBIDDEN_OPERATIONS):
    raise SecurityError("禁止的操作！")
```

**挑战3：连接管理**
```python
# 使用连接池
from sqlalchemy import create_engine
engine = create_engine('sqlite:///db.sqlite', pool_size=10)

# 自动管理连接
with engine.connect() as conn:
    result = conn.execute(query)
```

**挑战4：结果格式化**
```python
# 查询结果转为易读格式
results = cursor.fetchall()
columns = [desc[0] for desc in cursor.description]

# 格式化为表格
table = format_as_table(results, columns)
```

**数据库工具的设计原则：**

**1. 安全第一**
```
• 参数化查询
• 操作白名单
• 权限检查
• 输入验证
```

**2. 易用性**
```
• 自然语言转SQL
• 自动格式化结果
• 错误提示友好
```

**3. 高性能**
```
• 连接池
• 查询缓存
• 分页查询
```

**4. 可扩展**
```
• 支持多种数据库
• 统一接口
• 插件化设计
```

**今天这一课，我要带你：**

**第一部分：SQL基础封装**
- SQLite操作
- 参数化查询
- 安全防护

**第二部分：高级数据库工具**
- 自然语言转SQL
- 结果格式化
- 错误处理

**第三部分：多数据库支持**
- MySQL/PostgreSQL
- SQLAlchemy集成
- 连接池管理

**第四部分：安全机制**
- SQL注入防护
- 权限控制
- 审计日志

**第五部分：完整实战**
- 数据查询Agent
- 智能分析
- 最佳实践

学完这一课，你的Agent将能操作数据库！

准备好了吗？让我们开始！"

---

### 💡 核心理念

```
【数据库 = Agent的记忆和知识库】

没有数据库：
• 信息有限
• 无法持久化
• 无法管理大量数据

有了数据库：
• 海量数据
• 持久化存储
• 高效查询

【安全是第一原则】

永远记住：
• 参数化查询
• 白名单机制
• 最小权限原则
```

---

## 📚 第一部分：SQL基础封装

### 一、SQLite工具基础实现

```python
import sqlite3
from typing import List, Dict, Any, Optional, Tuple
import re
from contextlib import contextmanager

class DatabaseError(Exception):
    """数据库错误"""
    pass

class SQLiteTool:
    """SQLite数据库工具"""
    
    def __init__(self, database_path: str = ":memory:"):
        self.name = "sqlite_query"
        self.description = "查询SQLite数据库。输入SQL查询语句。"
        self.database_path = database_path
        
        # 安全配置
        self.allowed_operations = ['SELECT', 'INSERT', 'UPDATE']
        self.forbidden_operations = ['DROP', 'DELETE', 'TRUNCATE', 'ALTER']
        
        # 最大返回行数
        self.max_rows = 100
    
    @contextmanager
    def get_connection(self):
        """获取数据库连接（上下文管理器）"""
        conn = sqlite3.connect(self.database_path)
        conn.row_factory = sqlite3.Row  # 使用Row工厂
        try:
            yield conn
        finally:
            conn.close()
    
    def run(self, sql: str, params: Tuple = None) -> str:
        """
        执行SQL查询
        
        Args:
            sql: SQL查询语句
            params: 参数化查询的参数
        """
        try:
            # 1. 安全检查
            self._validate_sql(sql)
            
            # 2. 执行查询
            with self.get_connection() as conn:
                cursor = conn.cursor()
                
                if params:
                    cursor.execute(sql, params)
                else:
                    cursor.execute(sql)
                
                # 3. 获取结果
                if sql.strip().upper().startswith('SELECT'):
                    results = cursor.fetchmany(self.max_rows)
                    return self._format_results(results, cursor.description)
                else:
                    conn.commit()
                    return f"执行成功，影响{cursor.rowcount}行"
                    
        except sqlite3.Error as e:
            return f"数据库错误：{str(e)}"
        except DatabaseError as e:
            return f"安全错误：{str(e)}"
        except Exception as e:
            return f"错误：{str(e)}"
    
    def _validate_sql(self, sql: str):
        """验证SQL安全性"""
        
        sql_upper = sql.upper()
        
        # 检查禁止的操作
        for operation in self.forbidden_operations:
            if operation in sql_upper:
                raise DatabaseError(f"禁止的操作：{operation}")
        
        # 检查多语句（防止注入）
        if ';' in sql and sql.count(';') > 1:
            raise DatabaseError("不允许执行多条SQL语句")
    
    def _format_results(
        self,
        results: List[sqlite3.Row],
        description: List[Tuple]
    ) -> str:
        """格式化查询结果"""
        
        if not results:
            return "查询结果为空"
        
        # 获取列名
        columns = [desc[0] for desc in description]
        
        # 构建表格
        lines = []
        
        # 表头
        header = " | ".join(columns)
        lines.append(header)
        lines.append("-" * len(header))
        
        # 数据行
        for row in results:
            row_data = " | ".join(str(row[col]) for col in columns)
            lines.append(row_data)
        
        result_text = "\n".join(lines)
        
        # 如果结果被截断，添加提示
        if len(results) >= self.max_rows:
            result_text += f"\n\n注意：结果已截断，最多显示{self.max_rows}行"
        
        return result_text
    
    def to_dict(self) -> Dict:
        """转为工具定义"""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "sql": {
                            "type": "string",
                            "description": "SQL查询语句"
                        }
                    },
                    "required": ["sql"]
                }
            }
        }

# 演示
def demo_sqlite_tool():
    """演示SQLite工具"""
    
    # 创建测试数据库
    tool = SQLiteTool("test.db")
    
    print("="*60)
    print("SQLite工具演示")
    print("="*60)
    
    # 创建测试表
    print("\n1. 创建测试表")
    result = tool.run("""
        CREATE TABLE IF NOT EXISTS employees (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            department TEXT,
            salary REAL
        )
    """)
    print(result)
    
    # 插入测试数据
    print("\n2. 插入测试数据")
    test_data = [
        "INSERT INTO employees (name, department, salary) VALUES ('张三', '技术部', 15000)",
        "INSERT INTO employees (name, department, salary) VALUES ('李四', '销售部', 12000)",
        "INSERT INTO employees (name, department, salary) VALUES ('王五', '技术部', 18000)",
    ]
    for sql in test_data:
        result = tool.run(sql)
        print(result)
    
    # 查询数据
    print("\n3. 查询所有员工")
    result = tool.run("SELECT * FROM employees")
    print(result)
    
    print("\n4. 查询技术部员工")
    result = tool.run("SELECT * FROM employees WHERE department='技术部'")
    print(result)
    
    print("\n5. 计算平均工资")
    result = tool.run("SELECT AVG(salary) as avg_salary FROM employees")
    print(result)
    
    # 测试安全机制
    print("\n6. 测试安全机制（尝试DROP）")
    result = tool.run("DROP TABLE employees")
    print(result)

demo_sqlite_tool()
```

---

## 💻 第二部分：高级数据库工具

### 一、自然语言转SQL

```python
class NaturalLanguageToSQL:
    """自然语言转SQL工具"""
    
    def __init__(self, llm, database_schema: Dict):
        self.llm = llm
        self.database_schema = database_schema
    
    def convert(self, natural_query: str, verbose: bool = True) -> str:
        """将自然语言转换为SQL"""
        
        if verbose:
            print(f"\n自然语言: {natural_query}")
        
        # 构建Prompt
        schema_text = self._format_schema()
        
        prompt = f"""你是一个SQL专家。请将用户的自然语言查询转换为SQL语句。

数据库Schema：
{schema_text}

用户查询：{natural_query}

要求：
1. 只返回SQL语句，不要解释
2. 使用标准SQL语法
3. 确保SQL安全，不要使用DROP、DELETE等危险操作

SQL语句："""
        
        response = self.llm.invoke(prompt)
        sql = response.content.strip()
        
        # 清理SQL（去掉markdown格式）
        sql = sql.replace('```sql', '').replace('```', '').strip()
        
        if verbose:
            print(f"生成的SQL: {sql}")
        
        return sql
    
    def _format_schema(self) -> str:
        """格式化数据库Schema"""
        
        lines = []
        for table_name, columns in self.database_schema.items():
            lines.append(f"\n表：{table_name}")
            lines.append("列：")
            for col in columns:
                lines.append(f"  - {col['name']} ({col['type']})")
        
        return "\n".join(lines)

class SmartDatabaseTool:
    """智能数据库工具（支持自然语言）"""
    
    def __init__(self, llm, database_path: str):
        self.name = "smart_database_query"
        self.description = "使用自然语言查询数据库，如'查询所有员工'、'统计每个部门的平均工资'"
        
        self.db_tool = SQLiteTool(database_path)
        
        # 定义数据库Schema
        self.schema = self._detect_schema()
        
        # 创建NL2SQL转换器
        self.nl2sql = NaturalLanguageToSQL(llm, self.schema)
    
    def run(self, natural_query: str) -> str:
        """执行自然语言查询"""
        
        try:
            # 1. 转换为SQL
            sql = self.nl2sql.convert(natural_query)
            
            # 2. 执行SQL
            result = self.db_tool.run(sql)
            
            return result
            
        except Exception as e:
            return f"查询失败：{str(e)}"
    
    def _detect_schema(self) -> Dict:
        """检测数据库Schema"""
        
        schema = {}
        
        with self.db_tool.get_connection() as conn:
            cursor = conn.cursor()
            
            # 获取所有表
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
            """)
            
            tables = cursor.fetchall()
            
            # 获取每个表的列信息
            for (table_name,) in tables:
                cursor.execute(f"PRAGMA table_info({table_name})")
                columns = [
                    {
                        'name': col[1],
                        'type': col[2]
                    }
                    for col in cursor.fetchall()
                ]
                schema[table_name] = columns
        
        return schema
    
    def to_dict(self) -> Dict:
        """转为工具定义"""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": {
                        "natural_query": {
                            "type": "string",
                            "description": "自然语言查询，如'查询所有员工'、'统计平均工资'"
                        }
                    },
                    "required": ["natural_query"]
                }
            }
        }
```

---

## 🎯 第三部分：多数据库支持

### 一、SQLAlchemy集成

```python
from sqlalchemy import create_engine, text
from sqlalchemy.pool import QueuePool
from typing import Optional

class UniversalDatabaseTool:
    """通用数据库工具（支持多种数据库）"""
    
    def __init__(
        self,
        connection_string: str,
        pool_size: int = 5,
        max_overflow: int = 10
    ):
        """
        初始化
        
        连接字符串示例：
        - SQLite: sqlite:///database.db
        - MySQL: mysql+pymysql://user:pass@localhost/dbname
        - PostgreSQL: postgresql://user:pass@localhost/dbname
        """
        self.name = "database_query"
        self.description = "查询数据库"
        
        # 创建引擎（带连接池）
        self.engine = create_engine(
            connection_string,
            poolclass=QueuePool,
            pool_size=pool_size,
            max_overflow=max_overflow,
            echo=False
        )
        
        # 安全配置
        self.allowed_operations = ['SELECT', 'INSERT', 'UPDATE']
        self.max_rows = 100
    
    def run(self, sql: str) -> str:
        """执行SQL查询"""
        
        try:
            # 安全检查
            self._validate_sql(sql)
            
            # 执行查询
            with self.engine.connect() as conn:
                result = conn.execute(text(sql))
                
                if sql.strip().upper().startswith('SELECT'):
                    # 查询操作
                    rows = result.fetchmany(self.max_rows)
                    return self._format_results(rows, result.keys())
                else:
                    # 修改操作
                    conn.commit()
                    return f"执行成功，影响{result.rowcount}行"
                    
        except Exception as e:
            return f"数据库错误：{str(e)}"
    
    def _validate_sql(self, sql: str):
        """验证SQL"""
        sql_upper = sql.upper()
        
        # 检查危险操作
        dangerous = ['DROP', 'DELETE', 'TRUNCATE', 'ALTER']
        for op in dangerous:
            if op in sql_upper:
                raise DatabaseError(f"禁止的操作：{op}")
    
    def _format_results(self, rows: List, columns: List) -> str:
        """格式化结果"""
        
        if not rows:
            return "查询结果为空"
        
        # 构建表格
        lines = []
        
        # 表头
        header = " | ".join(str(col) for col in columns)
        lines.append(header)
        lines.append("-" * len(header))
        
        # 数据行
        for row in rows:
            row_data = " | ".join(str(val) for val in row)
            lines.append(row_data)
        
        return "\n".join(lines)
    
    def close(self):
        """关闭连接池"""
        self.engine.dispose()
```

---

## ⚡ 第四部分：安全机制

### 一、完整的安全防护

```python
import hashlib
import time
from collections import defaultdict

class SecureDatabaseTool:
    """安全的数据库工具"""
    
    def __init__(self, database_path: str):
        self.db_tool = SQLiteTool(database_path)
        
        # 审计日志
        self.audit_log = []
        
        # 速率限制
        self.rate_limit = {
            'max_queries_per_minute': 60,
            'query_times': defaultdict(list)
        }
        
        # SQL黑名单
        self.sql_blacklist = [
            'DROP', 'DELETE', 'TRUNCATE', 'ALTER',
            'EXEC', 'EXECUTE', 'UNION', '--', '/*'
        ]
    
    def run(
        self,
        sql: str,
        user_id: str = "anonymous"
    ) -> str:
        """安全执行SQL"""
        
        try:
            # 1. 速率限制检查
            if not self._check_rate_limit(user_id):
                return "错误：请求过于频繁，请稍后再试"
            
            # 2. SQL安全检查
            if not self._validate_sql_security(sql):
                self._log_security_event(user_id, sql, "SQL安全检查失败")
                return "错误：SQL语句包含不安全内容"
            
            # 3. 执行查询
            result = self.db_tool.run(sql)
            
            # 4. 记录审计日志
            self._log_query(user_id, sql, "成功")
            
            return result
            
        except Exception as e:
            self._log_query(user_id, sql, f"失败: {str(e)}")
            return f"错误：{str(e)}"
    
    def _check_rate_limit(self, user_id: str) -> bool:
        """检查速率限制"""
        
        current_time = time.time()
        user_queries = self.rate_limit['query_times'][user_id]
        
        # 清除1分钟前的记录
        user_queries = [t for t in user_queries if current_time - t < 60]
        self.rate_limit['query_times'][user_id] = user_queries
        
        # 检查是否超过限制
        if len(user_queries) >= self.rate_limit['max_queries_per_minute']:
            return False
        
        # 记录本次查询
        user_queries.append(current_time)
        return True
    
    def _validate_sql_security(self, sql: str) -> bool:
        """验证SQL安全性"""
        
        sql_upper = sql.upper()
        
        # 检查黑名单
        for keyword in self.sql_blacklist:
            if keyword in sql_upper:
                return False
        
        # 检查多语句
        if sql.count(';') > 1:
            return False
        
        return True
    
    def _log_query(self, user_id: str, sql: str, status: str):
        """记录查询日志"""
        
        log_entry = {
            'timestamp': time.time(),
            'user_id': user_id,
            'sql_hash': hashlib.md5(sql.encode()).hexdigest(),
            'status': status
        }
        
        self.audit_log.append(log_entry)
    
    def _log_security_event(self, user_id: str, sql: str, reason: str):
        """记录安全事件"""
        
        print(f"⚠️  安全警告")
        print(f"  用户: {user_id}")
        print(f"  原因: {reason}")
        print(f"  SQL: {sql[:100]}...")
    
    def get_audit_log(self) -> List[Dict]:
        """获取审计日志"""
        return self.audit_log
```

---

## 📝 课后练习

### 练习1：支持更多数据库
添加MongoDB、Redis支持

### 练习2：查询优化
实现查询缓存和索引建议

### 练习3：可视化
将查询结果可视化为图表

---

## 🎓 知识总结

### 核心要点

1. **安全第一**
   - 参数化查询
   - SQL注入防护
   - 操作白名单
   - 审计日志

2. **易用性**
   - 自然语言转SQL
   - 结果格式化
   - 友好的错误提示

3. **性能优化**
   - 连接池
   - 查询缓存
   - 分页查询

4. **多数据库支持**
   - SQLite
   - MySQL/PostgreSQL
   - SQLAlchemy

---

## 🚀 下节预告

下一课：**第81课：自定义工具开发-文件系统操作**

- 文件读写
- 目录操作
- 安全控制
- 批量处理

**让Agent操作文件系统！** 📁

---

**💪 记住：数据库是Agent的知识库，安全是第一原则！**

**下一课见！** 🎉
