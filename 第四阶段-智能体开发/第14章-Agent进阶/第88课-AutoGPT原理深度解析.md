![Agentè¿›é˜¶æ¶æ„](./images/agent.svg)
*å›¾ï¼šAgentè¿›é˜¶æ¶æ„*

# ç¬¬88è¯¾ï¼šAutoGPTåŸç†æ·±åº¦è§£æ

> **æœ¬è¯¾ç›®æ ‡**ï¼šæ·±å…¥ç†è§£AutoGPTçš„æ¶æ„å’Œå®ç°åŸç†ï¼ŒæŒæ¡è‡ªä¸»Agentå¼€å‘
> 
> **æ ¸å¿ƒæŠ€èƒ½**ï¼šè‡ªä¸»è§„åˆ’ã€é•¿æœŸè®°å¿†ã€ç›®æ ‡åˆ†è§£ã€è‡ªæˆ‘åæ€
> 
> **å®æˆ˜æ¡ˆä¾‹**ï¼šå®ç°Mini-AutoGPT
> 
> **å­¦ä¹ æ—¶é•¿**ï¼š95åˆ†é’Ÿ

---

## ğŸ“– å£æ’­æ–‡æ¡ˆï¼ˆ6åˆ†é’Ÿï¼‰
![Agent Debug](./images/agent_debug.svg)
*å›¾ï¼šAgent Debug*


### ğŸ¯ å‰è¨€

"å‰é¢æˆ‘ä»¬å­¦ä¹ äº†Agentçš„å®‰å…¨æ€§å’Œå¯è§‚æµ‹æ€§ã€‚

ä»Šå¤©æˆ‘ä»¬è¦æ·±å…¥ç ”ç©¶ä¸€ä¸ªé©å‘½æ€§çš„é¡¹ç›®ï¼š**AutoGPTï¼**

**AutoGPTæ˜¯ä»€ä¹ˆï¼Ÿ**

ç®€å•è¯´ï¼š**èƒ½è‡ªä¸»å®Œæˆå¤æ‚ä»»åŠ¡çš„Agentï¼**

**ä¼ ç»ŸAgent vs AutoGPTï¼š**

**ä¼ ç»ŸAgentï¼š**
```
ç”¨æˆ·ï¼š"å¸®æˆ‘å†™ä¸€ç¯‡æ–‡ç« "

Agentæ‰§è¡Œï¼š
1. ç”Ÿæˆæ–‡ç«  âœ…
2. å®Œæˆ

ç‰¹ç‚¹ï¼š
â€¢ å•æ­¥æ‰§è¡Œ
â€¢ éœ€è¦æ˜ç¡®æŒ‡ä»¤
â€¢ æ— æ³•å¤„ç†å¤æ‚ä»»åŠ¡
```

**AutoGPTï¼š**
```
ç”¨æˆ·ï¼š"åˆ›å»ºä¸€ä¸ªæˆåŠŸçš„ç§‘æŠ€åšå®¢"

AutoGPTè‡ªä¸»è§„åˆ’ï¼š
1. ç ”ç©¶çƒ­é—¨ç§‘æŠ€è¯é¢˜
2. åˆ†æç«äº‰å¯¹æ‰‹
3. è®¾è®¡åšå®¢æ¶æ„
4. åˆ›å»ºå†…å®¹æ—¥å†
5. æ’°å†™ç¬¬ä¸€æ‰¹æ–‡ç« 
6. SEOä¼˜åŒ–
7. ç¤¾äº¤åª’ä½“æ¨å¹¿
...

ç‰¹ç‚¹ï¼š
â€¢ å¤šæ­¥è‡ªä¸»æ‰§è¡Œ
â€¢ è‡ªå·±æ‹†è§£ä»»åŠ¡
â€¢ æŒç»­åˆ°è¾¾ç›®æ ‡
```

**AutoGPTçš„é©å‘½æ€§åœ¨å“ªé‡Œï¼Ÿ**

**é©å‘½ç‚¹1ï¼šè‡ªä¸»è§„åˆ’ï¼ˆAutonomous Planningï¼‰**
```
ç”¨æˆ·ç»™ä¸€ä¸ªé«˜å±‚æ¬¡ç›®æ ‡ï¼š
"å¸®æˆ‘åˆ›ä¸šï¼Œåšä¸€ä¸ªæœ‰åˆ©å¯å›¾çš„åœ¨çº¿ä¸šåŠ¡"

AutoGPTè‡ªå·±è§„åˆ’ï¼š
Step 1: å¸‚åœºè°ƒç ”
  - æœç´¢çƒ­é—¨å¸‚åœº
  - åˆ†æç«äº‰æƒ…å†µ
  - è¯„ä¼°å¸‚åœºè§„æ¨¡

Step 2: å•†ä¸šæ¨¡å¼è®¾è®¡
  - é€‰æ‹©å•†ä¸šæ¨¡å¼
  - è®¡ç®—æˆæœ¬
  - é¢„æµ‹æ”¶å…¥

Step 3: äº§å“å¼€å‘
  - è®¾è®¡äº§å“
  - å¼€å‘MVP
  - æµ‹è¯•

...

å®Œå…¨è‡ªä¸»ï¼ä¸éœ€è¦ä½ æ¯æ­¥æŒ‡å¯¼ï¼
```

**é©å‘½ç‚¹2ï¼šé•¿æœŸè®°å¿†ï¼ˆLong-term Memoryï¼‰**
```
ä¼ ç»ŸAgentï¼š
æ¯æ¬¡å¯¹è¯éƒ½æ˜¯æ–°çš„ï¼Œå¿˜è®°ä¹‹å‰çš„å†…å®¹

AutoGPTï¼š
â€¢ è®°ä½æ‰€æœ‰å†å²
â€¢ å­¦ä¹ ç»éªŒæ•™è®­
â€¢ æŒç»­æ”¹è¿›ç­–ç•¥

ç¤ºä¾‹ï¼š
Day 1: å°è¯•æ–¹æ¡ˆA â†’ å¤±è´¥
Day 2: AutoGPTè®°ä½å¤±è´¥ï¼Œå°è¯•æ–¹æ¡ˆB
Day 3: åŸºäºBçš„æˆåŠŸï¼Œä¼˜åŒ–ä¸ºæ–¹æ¡ˆC

æŒç»­è¿›åŒ–ï¼
```

**é©å‘½ç‚¹3ï¼šè‡ªæˆ‘åæ€ï¼ˆSelf-reflectionï¼‰**
```
AutoGPTä¼šé—®è‡ªå·±ï¼š
â€¢ "è¿™ä¸ªè®¡åˆ’åˆç†å—ï¼Ÿ"
â€¢ "æˆ‘è¿˜ç¼ºå°‘ä»€ä¹ˆä¿¡æ¯ï¼Ÿ"
â€¢ "æœ‰æ›´å¥½çš„æ–¹æ³•å—ï¼Ÿ"
â€¢ "ä¸Šæ¬¡ä¸ºä»€ä¹ˆå¤±è´¥ï¼Ÿ"

ç„¶åè°ƒæ•´ç­–ç•¥ï¼

å°±åƒäººç±»çš„æ€è€ƒè¿‡ç¨‹ï¼
```

**é©å‘½ç‚¹4ï¼šæ— é™å¾ªç¯ï¼ˆContinuous Loopï¼‰**
```
ä¼ ç»ŸAgentï¼š
ä»»åŠ¡ â†’ æ‰§è¡Œ â†’ å®Œæˆ

AutoGPTï¼š
ç›®æ ‡ â†’ è§„åˆ’ â†’ æ‰§è¡Œ â†’ è¯„ä¼° â†’ è°ƒæ•´ â†’ ç»§ç»­...

ç›´åˆ°ç›®æ ‡è¾¾æˆï¼
```

**AutoGPTçš„æ ¸å¿ƒæ¶æ„ï¼š**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         User Goal (ç”¨æˆ·ç›®æ ‡)          â”‚
â”‚    "åˆ›å»ºä¸€ä¸ªæˆåŠŸçš„ç§‘æŠ€åšå®¢"             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Planner (è§„åˆ’å™¨)                  â”‚
â”‚    â€¢ åˆ†è§£ç›®æ ‡ä¸ºå­ä»»åŠ¡                 â”‚
â”‚    â€¢ åˆ¶å®šæ‰§è¡Œè®¡åˆ’                     â”‚
â”‚    â€¢ è¯„ä¼°ä¼˜å…ˆçº§                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Executor (æ‰§è¡Œå™¨)                 â”‚
â”‚    â€¢ æ‰§è¡Œè®¡åˆ’ä¸­çš„ä»»åŠ¡                 â”‚
â”‚    â€¢ è°ƒç”¨å·¥å…·                         â”‚
â”‚    â€¢ æ”¶é›†ç»“æœ                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Memory (è®°å¿†ç³»ç»Ÿ)                 â”‚
â”‚    â€¢ çŸ­æœŸè®°å¿†ï¼šå½“å‰ä¸Šä¸‹æ–‡             â”‚
â”‚    â€¢ é•¿æœŸè®°å¿†ï¼šå‘é‡æ•°æ®åº“             â”‚
â”‚    â€¢ ç»éªŒæ€»ç»“                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Critic (è¯„ä¼°å™¨)                   â”‚
â”‚    â€¢ è¯„ä¼°æ‰§è¡Œç»“æœ                     â”‚
â”‚    â€¢ åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡                 â”‚
â”‚    â€¢ å†³å®šä¸‹ä¸€æ­¥                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        ç›®æ ‡è¾¾æˆï¼Ÿ
        /        \
      æ˜¯          å¦
      â†“           â†“
     ç»“æŸ        å¾ªç¯
```

**AutoGPTçš„æ‰§è¡Œæµç¨‹ï¼š**

```
ã€ç¬¬1æ­¥ã€‘æ¥æ”¶ç›®æ ‡
ç”¨æˆ·ï¼š"åˆ›å»ºä¸€ä¸ªå¾…åŠäº‹é¡¹åº”ç”¨"

ã€ç¬¬2æ­¥ã€‘è§„åˆ’
AutoGPTæ€è€ƒï¼š
"éœ€è¦åšä»€ä¹ˆï¼Ÿ
1. éœ€æ±‚åˆ†æ
2. æŠ€æœ¯é€‰å‹
3. æ¶æ„è®¾è®¡
4. ç¼–ç å®ç°
5. æµ‹è¯•
6. éƒ¨ç½²"

ã€ç¬¬3æ­¥ã€‘æ‰§è¡Œç¬¬ä¸€ä¸ªä»»åŠ¡
ä»»åŠ¡1: éœ€æ±‚åˆ†æ
â€¢ æœç´¢ç±»ä¼¼åº”ç”¨
â€¢ åˆ†æåŠŸèƒ½
â€¢ æ•´ç†éœ€æ±‚æ–‡æ¡£

ã€ç¬¬4æ­¥ã€‘è¯„ä¼°è¿›å±•
"éœ€æ±‚åˆ†æå®Œæˆ âœ…
ä¸‹ä¸€æ­¥ï¼šæŠ€æœ¯é€‰å‹"

ã€ç¬¬5æ­¥ã€‘ç»§ç»­æ‰§è¡Œ
ä»»åŠ¡2: æŠ€æœ¯é€‰å‹
â€¢ ç ”ç©¶æŠ€æœ¯æ ˆ
â€¢ å¯¹æ¯”ä¼˜ç¼ºç‚¹
â€¢ åšå‡ºå†³ç­–

ã€ç¬¬6æ­¥ã€‘è‡ªæˆ‘åæ€
"æˆ‘é€‰æ‹©çš„æŠ€æœ¯æ ˆåˆé€‚å—ï¼Ÿ
æœ‰æ²¡æœ‰æ›´å¥½çš„é€‰æ‹©ï¼Ÿ
éœ€è¦è°ƒæ•´å—ï¼Ÿ"

ã€ç¬¬7æ­¥ã€‘æŒç»­å¾ªç¯
ç›´åˆ°åº”ç”¨å®Œæˆï¼
```

**çœŸå®AutoGPTæ¡ˆä¾‹ï¼š**

**æ¡ˆä¾‹1ï¼šè‡ªä¸»åˆ›ä¸šç ”ç©¶**
```
ç›®æ ‡ï¼š"æ‰¾åˆ°ä¸€ä¸ªæœ‰åˆ©å¯å›¾çš„åœ¨çº¿ä¸šåŠ¡æœºä¼š"

AutoGPTæ‰§è¡Œäº†50+æ­¥ï¼š
â€¢ æœç´¢å½“å‰çƒ­é—¨å¸‚åœº
â€¢ åˆ†æå¸‚åœºè¶‹åŠ¿æŠ¥å‘Š
â€¢ ç ”ç©¶ç«äº‰å¯¹æ‰‹
â€¢ è®¡ç®—å¯åŠ¨æˆæœ¬
â€¢ è¯„ä¼°åˆ©æ¶¦ç©ºé—´
â€¢ åˆ†æé£é™©å› ç´ 
â€¢ ç”Ÿæˆå•†ä¸šè®¡åˆ’ä¹¦
â€¢ ç»™å‡ºå…·ä½“å»ºè®®

ç»“æœï¼š
æä¾›äº†3ä¸ªè¯¦ç»†çš„å•†ä¸šæœºä¼š
åŒ…å«å®Œæ•´çš„åˆ†æå’Œæ‰§è¡Œè®¡åˆ’

äººç±»å¯èƒ½éœ€è¦å‡ å‘¨
AutoGPTå‡ å°æ—¶å®Œæˆï¼
```

**æ¡ˆä¾‹2ï¼šè‡ªåŠ¨ä»£ç ç”Ÿæˆ**
```
ç›®æ ‡ï¼š"åˆ›å»ºä¸€ä¸ªå¤©æ°”æŸ¥è¯¢ç½‘ç«™"

AutoGPTè‡ªä¸»å®Œæˆï¼š
â€¢ è®¾è®¡ç½‘ç«™æ¶æ„
â€¢ é€‰æ‹©æŠ€æœ¯æ ˆï¼ˆReact + Node.jsï¼‰
â€¢ æŸ¥æ‰¾å¤©æ°”API
â€¢ ç”Ÿæˆå‰ç«¯ä»£ç 
â€¢ ç”Ÿæˆåç«¯ä»£ç 
â€¢ ç¼–å†™æµ‹è¯•
â€¢ åˆ›å»ºéƒ¨ç½²è„šæœ¬
â€¢ ç”ŸæˆREADMEæ–‡æ¡£

ç»“æœï¼š
å®Œæ•´å¯è¿è¡Œçš„é¡¹ç›®
åŒ…å«æ‰€æœ‰å¿…è¦æ–‡ä»¶ï¼
```

**AutoGPTçš„æŒ‘æˆ˜ï¼š**

**æŒ‘æˆ˜1ï¼šæˆæœ¬é«˜**
```
é—®é¢˜ï¼š
æ¯ä¸ªå¾ªç¯éƒ½éœ€è¦è°ƒç”¨LLM
ä¸€ä¸ªä»»åŠ¡å¯èƒ½éœ€è¦50+æ¬¡è°ƒç”¨

æˆæœ¬ï¼š
GPT-4: $0.03/1K tokens
å¤æ‚ä»»åŠ¡: $1-$10

è§£å†³æ–¹æ¡ˆï¼š
â€¢ ä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹
â€¢ ä¼˜åŒ–Prompt
â€¢ é™åˆ¶å¾ªç¯æ¬¡æ•°
```

**æŒ‘æˆ˜2ï¼šå¯èƒ½é™·å…¥å¾ªç¯**
```
é—®é¢˜ï¼š
AutoGPTå¯èƒ½é‡å¤æ‰§è¡Œç›¸åŒä»»åŠ¡

ç¤ºä¾‹ï¼š
æœç´¢ â†’ åˆ†æ â†’ è§‰å¾—ä¿¡æ¯ä¸å¤Ÿ â†’ å†æœç´¢ â†’ å†åˆ†æ â†’ ...

è§£å†³æ–¹æ¡ˆï¼š
â€¢ å¾ªç¯æ£€æµ‹
â€¢ æœ€å¤§è¿­ä»£é™åˆ¶
â€¢ è¿›å±•è¯„ä¼°
```

**æŒ‘æˆ˜3ï¼šè´¨é‡ä¸ç¨³å®š**
```
é—®é¢˜ï¼š
ä¸æ˜¯æ¯æ¬¡éƒ½èƒ½å®Œç¾å®Œæˆä»»åŠ¡

åŸå› ï¼š
â€¢ LLMçš„éšæœºæ€§
â€¢ è§„åˆ’å¯èƒ½ä¸å®Œå–„
â€¢ å·¥å…·è°ƒç”¨å¯èƒ½å¤±è´¥

è§£å†³æ–¹æ¡ˆï¼š
â€¢ å¤šæ¬¡å°è¯•
â€¢ äººå·¥ç›‘ç£
â€¢ å…³é”®æ­¥éª¤äººå·¥å®¡æ ¸
```

**ä»Šå¤©è¿™ä¸€è¯¾ï¼Œæˆ‘è¦å¸¦ä½ ï¼š**

**ç¬¬ä¸€éƒ¨åˆ†ï¼šAutoGPTæ¶æ„**
- æ ¸å¿ƒç»„ä»¶
- å·¥ä½œæµç¨‹
- è®¾è®¡æ¨¡å¼

**ç¬¬äºŒéƒ¨åˆ†ï¼šè§„åˆ’ç³»ç»Ÿ**
- ç›®æ ‡åˆ†è§£
- ä»»åŠ¡è§„åˆ’
- ä¼˜å…ˆçº§æ’åº

**ç¬¬ä¸‰éƒ¨åˆ†ï¼šè®°å¿†ç³»ç»Ÿ**
- çŸ­æœŸè®°å¿†
- é•¿æœŸè®°å¿†
- å‘é‡æ•°æ®åº“

**ç¬¬å››éƒ¨åˆ†ï¼šè‡ªæˆ‘åæ€**
- è¿›å±•è¯„ä¼°
- ç­–ç•¥è°ƒæ•´
- ç»éªŒå­¦ä¹ 

**ç¬¬äº”éƒ¨åˆ†ï¼šå®Œæ•´å®æˆ˜**
- Mini-AutoGPTå®ç°
- å®é™…åº”ç”¨
- æœ€ä½³å®è·µ

å­¦å®Œè¿™ä¸€è¯¾ï¼Œä½ å°†èƒ½åˆ›å»ºè‡ªä¸»Agentï¼

å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹ï¼"

---

### ğŸ’¡ æ ¸å¿ƒç†å¿µ

```
ã€AutoGPT = è‡ªä¸»çš„AI Agentã€‘

ä¼ ç»ŸAgentï¼š
â€¢ è¢«åŠ¨å“åº”
â€¢ å•æ­¥æ‰§è¡Œ
â€¢ éœ€è¦æ˜ç¡®æŒ‡ä»¤

AutoGPTï¼š
â€¢ ä¸»åŠ¨è§„åˆ’
â€¢ å¤šæ­¥æ‰§è¡Œ
â€¢ è‡ªä¸»å†³ç­–

ã€å…³é”®æ˜¯"è‡ªä¸»æ€§"ã€‘

ä¸æ˜¯ï¼š
â€¢ è®©AIåšå•ä¸ªä»»åŠ¡

è€Œæ˜¯ï¼š
â€¢ è®©AIè‡ªå·±è§„åˆ’
â€¢ è‡ªå·±æ‰§è¡Œ
â€¢ è‡ªå·±è¯„ä¼°
â€¢ è‡ªå·±æ”¹è¿›
```

---

## ğŸ“š ç¬¬ä¸€éƒ¨åˆ†ï¼šAutoGPTæ ¸å¿ƒæ¶æ„

### ä¸€ã€åŸºç¡€ç»„ä»¶å®ç°

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
from enum import Enum
import json

class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class Task:
    """ä»»åŠ¡"""
    task_id: str
    description: str
    status: TaskStatus
    priority: int
    result: Optional[str] = None
    reasoning: Optional[str] = None

@dataclass
class Goal:
    """ç›®æ ‡"""
    goal_id: str
    description: str
    success_criteria: List[str]
    tasks: List[Task] = field(default_factory=list)

class Planner:
    """è§„åˆ’å™¨"""
    
    def __init__(self, llm):
        self.llm = llm
    
    def create_plan(self, goal: str) -> List[Task]:
        """
        æ ¹æ®ç›®æ ‡åˆ›å»ºæ‰§è¡Œè®¡åˆ’
        
        ç­–ç•¥ï¼š
        1. åˆ†è§£ç›®æ ‡ä¸ºå­ä»»åŠ¡
        2. ç¡®å®šä»»åŠ¡ä¾èµ–
        3. åˆ†é…ä¼˜å…ˆçº§
        """
        
        prompt = f"""
Given the following goal, break it down into a series of specific, actionable tasks.

Goal: {goal}

Create a step-by-step plan. For each task, provide:
1. A clear description
2. Priority (1-10, higher is more important)
3. Dependencies (which tasks must be completed first)

Format as JSON array:
[
    {{
        "task_id": "1",
        "description": "...",
        "priority": 8,
        "dependencies": []
    }},
    ...
]
"""
        
        response = self.llm.invoke(prompt)
        
        # è§£æä»»åŠ¡åˆ—è¡¨
        try:
            tasks_data = json.loads(response.content)
            
            tasks = []
            for task_data in tasks_data:
                task = Task(
                    task_id=task_data["task_id"],
                    description=task_data["description"],
                    status=TaskStatus.PENDING,
                    priority=task_data["priority"]
                )
                tasks.append(task)
            
            return tasks
            
        except:
            # è§£æå¤±è´¥ï¼Œè¿”å›ç©ºåˆ—è¡¨
            return []
    
    def replan(
        self,
        original_goal: str,
        completed_tasks: List[Task],
        current_situation: str
    ) -> List[Task]:
        """
        æ ¹æ®å½“å‰æƒ…å†µé‡æ–°è§„åˆ’
        
        å½“å‘ç°è®¡åˆ’ä¸åˆé€‚æ—¶è°ƒç”¨
        """
        
        completed_str = "\n".join([
            f"- {task.description}: {task.result}"
            for task in completed_tasks
        ])
        
        prompt = f"""
Original Goal: {original_goal}

Completed Tasks:
{completed_str}

Current Situation: {current_situation}

Based on the progress so far, create a new plan for the remaining work.
What tasks should be done next to achieve the goal?

Format as JSON array (same format as before).
"""
        
        response = self.llm.invoke(prompt)
        
        # è§£ææ–°ä»»åŠ¡åˆ—è¡¨
        # ï¼ˆå®ç°åŒcreate_planï¼‰
        
        return []

class Executor:
    """æ‰§è¡Œå™¨"""
    
    def __init__(self, llm, tools: Dict):
        self.llm = llm
        self.tools = tools
    
    def execute_task(self, task: Task, context: Dict) -> str:
        """
        æ‰§è¡Œå•ä¸ªä»»åŠ¡
        
        Args:
            task: è¦æ‰§è¡Œçš„ä»»åŠ¡
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆä¹‹å‰ä»»åŠ¡çš„ç»“æœç­‰ï¼‰
        
        Returns:
            æ‰§è¡Œç»“æœ
        """
        
        # æ„å»ºæ‰§è¡ŒPrompt
        prompt = self._build_execution_prompt(task, context)
        
        # è°ƒç”¨LLMå†³å®šå¦‚ä½•æ‰§è¡Œ
        response = self.llm.invoke(
            prompt,
            tools=[tool.to_dict() for tool in self.tools.values()]
        )
        
        # å¤„ç†å·¥å…·è°ƒç”¨
        if hasattr(response, 'tool_calls') and response.tool_calls:
            # æ‰§è¡Œå·¥å…·
            results = []
            for tool_call in response.tool_calls:
                result = self._execute_tool(tool_call)
                results.append(result)
            
            # æ€»ç»“ç»“æœ
            summary = self._summarize_results(task, results)
            return summary
        else:
            # ç›´æ¥è¿”å›LLMçš„å›ç­”
            return response.content
    
    def _build_execution_prompt(self, task: Task, context: Dict) -> str:
        """æ„å»ºæ‰§è¡ŒPrompt"""
        
        context_str = json.dumps(context, ensure_ascii=False, indent=2)
        
        prompt = f"""
Task: {task.description}

Context from previous tasks:
{context_str}

Execute this task. You can use available tools or provide direct answer.
Be specific and thorough.
"""
        
        return prompt
    
    def _execute_tool(self, tool_call) -> str:
        """æ‰§è¡Œå·¥å…·"""
        
        tool_name = tool_call.function.name
        arguments = json.loads(tool_call.function.arguments)
        
        tool = self.tools.get(tool_name)
        if not tool:
            return f"Error: Tool {tool_name} not found"
        
        try:
            result = tool.run(**arguments)
            return str(result)
        except Exception as e:
            return f"Error: {str(e)}"
    
    def _summarize_results(self, task: Task, results: List[str]) -> str:
        """æ€»ç»“æ‰§è¡Œç»“æœ"""
        
        results_str = "\n".join(results)
        
        prompt = f"""
Task: {task.description}

Execution results:
{results_str}

Provide a concise summary of what was accomplished.
"""
        
        response = self.llm.invoke(prompt)
        return response.content

class Critic:
    """è¯„ä¼°å™¨"""
    
    def __init__(self, llm):
        self.llm = llm
    
    def evaluate_progress(
        self,
        goal: str,
        completed_tasks: List[Task],
        remaining_tasks: List[Task]
    ) -> Dict:
        """
        è¯„ä¼°è¿›å±•
        
        Returns:
            {
                'progress_percentage': 0-100,
                'is_on_track': bool,
                'suggestions': List[str],
                'should_replan': bool
            }
        """
        
        completed_str = "\n".join([
            f"- {task.description}: {task.result}"
            for task in completed_tasks
        ])
        
        remaining_str = "\n".join([
            f"- {task.description}"
            for task in remaining_tasks
        ])
        
        prompt = f"""
Goal: {goal}

Completed Tasks:
{completed_str}

Remaining Tasks:
{remaining_str}

Evaluate the progress:
1. What percentage of the goal has been achieved? (0-100)
2. Are we on track to achieve the goal?
3. Should we adjust the plan?
4. Any suggestions for improvement?

Respond in JSON:
{{
    "progress_percentage": 60,
    "is_on_track": true,
    "should_replan": false,
    "suggestions": ["suggestion 1", "suggestion 2"]
}}
"""
        
        response = self.llm.invoke(prompt)
        
        try:
            evaluation = json.loads(response.content)
            return evaluation
        except:
            return {
                'progress_percentage': 50,
                'is_on_track': True,
                'should_replan': False,
                'suggestions': []
            }

class MiniAutoGPT:
    """Mini AutoGPTå®ç°"""
    
    def __init__(self, llm, tools: Dict, max_iterations: int = 20):
        self.llm = llm
        self.tools = tools
        self.max_iterations = max_iterations
        
        # æ ¸å¿ƒç»„ä»¶
        self.planner = Planner(llm)
        self.executor = Executor(llm, tools)
        self.critic = Critic(llm)
        
        # è®°å¿†
        self.completed_tasks: List[Task] = []
        self.context: Dict = {}
    
    def run(self, goal: str, verbose: bool = True):
        """
        æ‰§è¡Œç›®æ ‡
        
        ä¸»å¾ªç¯ï¼š
        1. è§„åˆ’
        2. æ‰§è¡Œ
        3. è¯„ä¼°
        4. å†³å®šæ˜¯å¦ç»§ç»­
        """
        
        if verbose:
            print("\n" + "="*60)
            print(f"ğŸ¯ ç›®æ ‡: {goal}")
            print("="*60)
        
        # åˆå§‹è§„åˆ’
        tasks = self.planner.create_plan(goal)
        
        if verbose:
            print(f"\nğŸ“‹ åˆå§‹è®¡åˆ’ï¼š{len(tasks)}ä¸ªä»»åŠ¡")
            for task in tasks:
                print(f"  {task.task_id}. {task.description}")
        
        # ä¸»å¾ªç¯
        for iteration in range(self.max_iterations):
            if verbose:
                print(f"\n--- è¿­ä»£ {iteration + 1} ---")
            
            # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä»»åŠ¡
            pending_tasks = [t for t in tasks if t.status == TaskStatus.PENDING]
            
            if not pending_tasks:
                if verbose:
                    print("âœ… æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼")
                break
            
            # é€‰æ‹©ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„ï¼‰
            next_task = max(pending_tasks, key=lambda t: t.priority)
            
            if verbose:
                print(f"\nğŸ”¨ æ‰§è¡Œä»»åŠ¡: {next_task.description}")
            
            # æ‰§è¡Œä»»åŠ¡
            next_task.status = TaskStatus.IN_PROGRESS
            
            try:
                result = self.executor.execute_task(next_task, self.context)
                next_task.result = result
                next_task.status = TaskStatus.COMPLETED
                
                # æ›´æ–°ä¸Šä¸‹æ–‡
                self.context[next_task.task_id] = result
                self.completed_tasks.append(next_task)
                
                if verbose:
                    print(f"  âœ… å®Œæˆ: {result[:100]}...")
                
            except Exception as e:
                next_task.status = TaskStatus.FAILED
                if verbose:
                    print(f"  âŒ å¤±è´¥: {str(e)}")
            
            # è¯„ä¼°è¿›å±•
            remaining = [t for t in tasks if t.status == TaskStatus.PENDING]
            evaluation = self.critic.evaluate_progress(
                goal,
                self.completed_tasks,
                remaining
            )
            
            if verbose:
                print(f"\nğŸ“Š è¿›å±•: {evaluation['progress_percentage']}%")
                if evaluation.get('suggestions'):
                    print("ğŸ’¡ å»ºè®®:")
                    for suggestion in evaluation['suggestions']:
                        print(f"  â€¢ {suggestion}")
            
            # æ˜¯å¦éœ€è¦é‡æ–°è§„åˆ’
            if evaluation.get('should_replan', False):
                if verbose:
                    print("\nğŸ”„ é‡æ–°è§„åˆ’...")
                
                new_tasks = self.planner.replan(
                    goal,
                    self.completed_tasks,
                    f"Progress: {evaluation['progress_percentage']}%"
                )
                
                # æ·»åŠ æ–°ä»»åŠ¡
                for new_task in new_tasks:
                    if new_task.task_id not in [t.task_id for t in tasks]:
                        tasks.append(new_task)
        
        # æœ€ç»ˆæ€»ç»“
        if verbose:
            print("\n" + "="*60)
            print("ğŸ‰ ä»»åŠ¡å®Œæˆ")
            print("="*60)
            print(f"\nå®Œæˆçš„ä»»åŠ¡ï¼š{len(self.completed_tasks)}")
            for task in self.completed_tasks:
                print(f"  âœ… {task.description}")
        
        return self.completed_tasks

# æ¼”ç¤ºï¼ˆéœ€è¦çœŸå®LLMï¼‰
def demo_mini_autogpt():
    """æ¼”ç¤ºMini AutoGPT"""
    
    print("="*60)
    print("Mini AutoGPTæ¼”ç¤º")
    print("="*60)
    print("\næ³¨æ„ï¼šéœ€è¦çœŸå®çš„LLMæ‰èƒ½è¿è¡Œ")
    print("è¿™é‡Œåªå±•ç¤ºæ¶æ„å’Œæµç¨‹")
    
    # æ¨¡æ‹Ÿå·¥å…·
    tools = {
        "search": type('SearchTool', (), {
            'run': lambda query: f"æœç´¢ç»“æœï¼š{query}ç›¸å…³ä¿¡æ¯...",
            'to_dict': lambda: {}
        })(),
    }
    
    # åˆ›å»ºAutoGPTï¼ˆéœ€è¦çœŸå®LLMï¼‰
    # autogpt = MiniAutoGPT(llm, tools)
    # autogpt.run("ç ”ç©¶Pythonå¼‚æ­¥ç¼–ç¨‹å¹¶å†™ä¸€ç¯‡æ•™ç¨‹")

demo_mini_autogpt()
```

---

## ğŸ’» ç¬¬äºŒéƒ¨åˆ†ï¼šé•¿æœŸè®°å¿†ç³»ç»Ÿ

### ä¸€ã€å‘é‡è®°å¿†å®ç°

```python
class VectorMemory:
    """å‘é‡è®°å¿†ç³»ç»Ÿ"""
    
    def __init__(self, embedding_model):
        self.embedding_model = embedding_model
        self.memories: List[Dict] = []
        self.embeddings: List = []
    
    def add_memory(self, content: str, metadata: Dict = None):
        """æ·»åŠ è®°å¿†"""
        
        # ç”Ÿæˆembedding
        embedding = self.embedding_model.embed(content)
        
        memory = {
            'content': content,
            'metadata': metadata or {},
            'timestamp': time.time()
        }
        
        self.memories.append(memory)
        self.embeddings.append(embedding)
    
    def search_memory(
        self,
        query: str,
        top_k: int = 5
    ) -> List[Dict]:
        """æœç´¢ç›¸å…³è®°å¿†"""
        
        # æŸ¥è¯¢embedding
        query_embedding = self.embedding_model.embed(query)
        
        # è®¡ç®—ç›¸ä¼¼åº¦
        similarities = []
        for i, emb in enumerate(self.embeddings):
            sim = self._cosine_similarity(query_embedding, emb)
            similarities.append((sim, i))
        
        # æ’åºå¹¶è¿”å›top_k
        similarities.sort(reverse=True)
        
        results = []
        for sim, idx in similarities[:top_k]:
            memory = self.memories[idx].copy()
            memory['similarity'] = sim
            results.append(memory)
        
        return results
    
    def _cosine_similarity(self, vec1, vec2):
        """è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦"""
        import numpy as np
        return np.dot(vec1, vec2) / (
            np.linalg.norm(vec1) * np.linalg.norm(vec2)
        )
```

---

## ğŸ“ è¯¾åç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°å®Œæ•´çš„è®°å¿†ç³»ç»Ÿ
ä½¿ç”¨å‘é‡æ•°æ®åº“å®ç°é•¿æœŸè®°å¿†

### ç»ƒä¹ 2ï¼šæ·»åŠ åæ€æœºåˆ¶
è®©Agentèƒ½å¤Ÿä»å¤±è´¥ä¸­å­¦ä¹ 

### ç»ƒä¹ 3ï¼šå®ç°ç›®æ ‡æ ‘
æ”¯æŒå¤æ‚çš„åµŒå¥—ç›®æ ‡

---

## ğŸ“ çŸ¥è¯†æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **AutoGPTæ¶æ„**
   - Plannerè§„åˆ’å™¨
   - Executoræ‰§è¡Œå™¨
   - Criticè¯„ä¼°å™¨
   - Memoryè®°å¿†ç³»ç»Ÿ

2. **è‡ªä¸»æ€§**
   - ç›®æ ‡åˆ†è§£
   - è‡ªä¸»è§„åˆ’
   - æŒç»­æ‰§è¡Œ
   - è‡ªæˆ‘è¯„ä¼°

3. **é•¿æœŸè®°å¿†**
   - å‘é‡å­˜å‚¨
   - ç›¸å…³æ£€ç´¢
   - ç»éªŒç§¯ç´¯

4. **å…³é”®æŒ‘æˆ˜**
   - æˆæœ¬æ§åˆ¶
   - å¾ªç¯æ£€æµ‹
   - è´¨é‡ä¿è¯

---

## ğŸš€ ä¸‹èŠ‚é¢„å‘Š

ä¸‹ä¸€è¯¾ï¼š**ç¬¬89è¯¾ï¼šBabyAGIæ¶æ„ä¸å®ç°**

- BabyAGIåŸç†
- ä»»åŠ¡ç®¡ç†
- ä¼˜å…ˆçº§é˜Ÿåˆ—
- å®ç°å¯¹æ¯”

**æ¢ç´¢å¦ä¸€ä¸ªè‡ªä¸»Agentï¼** ğŸ¼

---

**ğŸ’ª è®°ä½ï¼šAutoGPTä»£è¡¨äº†Agentçš„æœªæ¥æ–¹å‘ï¼**

**ä¸‹ä¸€è¯¾è§ï¼** ğŸ‰
